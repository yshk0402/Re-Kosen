{"version":3,"file":"node-request.cjs","sources":["../../src/middleware/defaultOptionsProcessor.ts","../../src/middleware/defaultOptionsValidator.ts","../../src/util/lowerCaseHeaders.ts","../../src/util/speedometer.ts","../../src/util/progress-stream.ts","../../src/request/node/proxy.ts","../../src/request/node/tunnel.ts","../../src/request/node-request.ts","../../src/request/node/simpleConcat.ts","../../src/request/node/timedOut.ts"],"sourcesContent":["import type {MiddlewareHooks, RequestOptions} from 'get-it'\n\nconst isReactNative = typeof navigator === 'undefined' ? false : navigator.product === 'ReactNative'\n\nconst defaultOptions = {timeout: isReactNative ? 60000 : 120000} satisfies Partial<RequestOptions>\n\n/** @public */\nexport const processOptions = function processOptions(opts) {\n  const options = {\n    ...defaultOptions,\n    ...(typeof opts === 'string' ? {url: opts} : opts),\n  } satisfies RequestOptions\n\n  // Normalize timeouts\n  options.timeout = normalizeTimeout(options.timeout)\n\n  // Shallow-merge (override) existing query params\n  if (options.query) {\n    const {url, searchParams} = splitUrl(options.url)\n\n    for (const [key, value] of Object.entries(options.query)) {\n      if (value !== undefined) {\n        if (Array.isArray(value)) {\n          for (const v of value) {\n            searchParams.append(key, v as string)\n          }\n        } else {\n          searchParams.append(key, value as string)\n        }\n      }\n\n      // Merge back params into url\n      const search = searchParams.toString()\n      if (search) {\n        options.url = `${url}?${search}`\n      }\n    }\n  }\n\n  // Implicit POST if we have not specified a method but have a body\n  options.method =\n    options.body && !options.method ? 'POST' : (options.method || 'GET').toUpperCase()\n\n  return options\n} satisfies MiddlewareHooks['processOptions']\n\n/**\n * Given a string URL, extracts the query string and URL from each other, and returns them.\n * Note that we cannot use the `URL` constructor because of old React Native versions which are\n * majorly broken and returns incorrect results:\n *\n * (`new URL('http://foo/?a=b').toString()` == 'http://foo/?a=b/')\n */\nfunction splitUrl(url: string): {url: string; searchParams: URLSearchParams} {\n  const qIndex = url.indexOf('?')\n  if (qIndex === -1) {\n    return {url, searchParams: new URLSearchParams()}\n  }\n\n  const base = url.slice(0, qIndex)\n  const qs = url.slice(qIndex + 1)\n\n  // React Native's URL and URLSearchParams are broken, so passing a string to URLSearchParams\n  // does not work, leading to an empty query string. For other environments, this should be enough\n  if (!isReactNative) {\n    return {url: base, searchParams: new URLSearchParams(qs)}\n  }\n\n  // Sanity-check; we do not know of any environment where this is the case,\n  // but if it is, we should not proceed without giving a descriptive error\n  if (typeof decodeURIComponent !== 'function') {\n    throw new Error(\n      'Broken `URLSearchParams` implementation, and `decodeURIComponent` is not defined',\n    )\n  }\n\n  const params = new URLSearchParams()\n  for (const pair of qs.split('&')) {\n    const [key, value] = pair.split('=')\n    if (key) {\n      params.append(decodeQueryParam(key), decodeQueryParam(value || ''))\n    }\n  }\n\n  return {url: base, searchParams: params}\n}\n\nfunction decodeQueryParam(value: string): string {\n  return decodeURIComponent(value.replace(/\\+/g, ' '))\n}\n\nfunction normalizeTimeout(time: RequestOptions['timeout']) {\n  if (time === false || time === 0) {\n    return false\n  }\n\n  if (time.connect || time.socket) {\n    return time\n  }\n\n  const delay = Number(time)\n  if (isNaN(delay)) {\n    return normalizeTimeout(defaultOptions.timeout)\n  }\n\n  return {connect: delay, socket: delay}\n}\n","import type {MiddlewareHooks} from 'get-it'\n\nconst validUrl = /^https?:\\/\\//i\n\n/** @public */\nexport const validateOptions = function validateOptions(options) {\n  if (!validUrl.test(options.url)) {\n    throw new Error(`\"${options.url}\" is not a valid URL`)\n  }\n} satisfies MiddlewareHooks['validateOptions']\n","export function lowerCaseHeaders(headers: any) {\n  return Object.keys(headers || {}).reduce((acc, header) => {\n    acc[header.toLowerCase()] = headers[header]\n    return acc\n  }, {} as any)\n}\n","/**\n * Inlined variant of npm `speedometer` (https://github.com/mafintosh/speedometer),\n * MIT-licensed, Copyright (c) 2013 Mathias Buus.\n */\n\nlet tick = 1\nconst maxTick = 65535\nconst resolution = 4\nlet timer: ReturnType<typeof setInterval> | null = null\n\nconst inc = function () {\n  tick = (tick + 1) & maxTick\n}\n\nexport function speedometer(seconds: number) {\n  if (!timer) {\n    timer = setInterval(inc, (1000 / resolution) | 0)\n    if (timer.unref) timer.unref()\n  }\n\n  const size = resolution * (seconds || 5)\n  const buffer = [0]\n  let pointer = 1\n  let last = (tick - 1) & maxTick\n\n  return {\n    getSpeed: function (delta: number) {\n      let dist = (tick - last) & maxTick\n      if (dist > size) dist = size\n      last = tick\n\n      while (dist--) {\n        if (pointer === size) pointer = 0\n        buffer[pointer] = buffer[pointer === 0 ? size - 1 : pointer - 1]\n        pointer++\n      }\n\n      if (delta) buffer[pointer - 1] += delta\n\n      const top = buffer[pointer - 1]\n      const btm = buffer.length < size ? 0 : buffer[pointer === size ? 0 : pointer]\n\n      return buffer.length < resolution ? top : ((top - btm) * resolution) / buffer.length\n    },\n    clear: function () {\n      if (timer) {\n        clearInterval(timer)\n        timer = null\n      }\n    },\n  }\n}\n","/**\n * Inlined, reduced variant of npm `progress-stream` (https://github.com/freeall/progress-stream),\n * that fixes a bug with `content-length` header. BSD 2-Clause Simplified License,\n * Copyright (c) Tobias BaunbÃ¦k <freeall@gmail.com>.\n */\nimport type {Transform} from 'stream'\nimport through from 'through2'\n\nimport {speedometer} from './speedometer'\n\nexport interface Progress {\n  percentage: number\n  transferred: number\n  length: number\n  remaining: number\n  eta: number\n  runtime: number\n  delta: number\n  speed: number\n}\n\nexport interface ProgressStream extends Transform {\n  progress(): Progress\n}\n\nexport function progressStream(options: {time: number; length?: number}): ProgressStream {\n  let length = options.length || 0\n  let transferred = 0\n  let nextUpdate = Date.now() + options.time\n  let delta = 0\n  const speed = speedometer(5)\n  const startTime = Date.now()\n\n  const update = {\n    percentage: 0,\n    transferred: transferred,\n    length: length,\n    remaining: length,\n    eta: 0,\n    runtime: 0,\n    speed: 0,\n    delta: 0,\n  }\n\n  const emit = function (ended: boolean) {\n    update.delta = delta\n    update.percentage = ended ? 100 : length ? (transferred / length) * 100 : 0\n    update.speed = speed.getSpeed(delta)\n    update.eta = Math.round(update.remaining / update.speed)\n    update.runtime = Math.floor((Date.now() - startTime) / 1000)\n    nextUpdate = Date.now() + options.time\n\n    delta = 0\n\n    tr.emit('progress', update)\n  }\n\n  const write = function (\n    chunk: Buffer,\n    _enc: string,\n    callback: (err: Error | null, data?: Buffer) => void,\n  ) {\n    const len = chunk.length\n    transferred += len\n    delta += len\n    update.transferred = transferred\n    update.remaining = length >= transferred ? length - transferred : 0\n\n    if (Date.now() >= nextUpdate) emit(false)\n    callback(null, chunk)\n  }\n\n  const end = function (callback: (err?: Error | null) => void) {\n    emit(true)\n    speed.clear()\n    callback()\n  }\n\n  const tr = through({}, write, end) as ProgressStream\n  const onlength = function (newLength: number) {\n    length = newLength\n    update.length = length\n    update.remaining = length - update.transferred\n    tr.emit('length', length)\n  }\n\n  tr.on('pipe', function (stream) {\n    if (length > 0) return\n\n    // Support http module\n    if (\n      stream.readable &&\n      !('writable' in stream) &&\n      'headers' in stream &&\n      isRecord(stream.headers)\n    ) {\n      const contentLength =\n        typeof stream.headers['content-length'] === 'string'\n          ? parseInt(stream.headers['content-length'], 10)\n          : 0\n      return onlength(contentLength)\n    }\n\n    // Support streams with a length property\n    if ('length' in stream && typeof stream.length === 'number') {\n      return onlength(stream.length)\n    }\n\n    // Support request module\n    stream.on('response', function (res) {\n      if (!res || !res.headers) return\n      if (res.headers['content-encoding'] === 'gzip') return\n      if (res.headers['content-length']) {\n        return onlength(parseInt(res.headers['content-length']))\n      }\n    })\n  })\n\n  tr.progress = function () {\n    update.speed = speed.getSpeed(0)\n    update.eta = Math.round(update.remaining / update.speed)\n\n    return update\n  }\n\n  return tr\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null && !Array.isArray(value)\n}\n","/**\n * Code borrowed from https://github.com/request/request\n * Apache License 2.0\n */\n\nimport url, {type UrlWithStringQuery} from 'url'\n\nimport type {ProxyOptions, RequestOptions} from '../../types'\n\nfunction formatHostname(hostname: string) {\n  // canonicalize the hostname, so that 'oogle.com' won't match 'google.com'\n  return hostname.replace(/^\\.*/, '.').toLowerCase()\n}\n\nfunction parseNoProxyZone(zoneStr: string) {\n  const zone = zoneStr.trim().toLowerCase()\n\n  const zoneParts = zone.split(':', 2)\n  const zoneHost = formatHostname(zoneParts[0])\n  const zonePort = zoneParts[1]\n  const hasPort = zone.indexOf(':') > -1\n\n  return {hostname: zoneHost, port: zonePort, hasPort: hasPort}\n}\n\nfunction uriInNoProxy(uri: UrlWithStringQuery, noProxy: string) {\n  const port = uri.port || (uri.protocol === 'https:' ? '443' : '80')\n  const hostname = formatHostname(uri.hostname || '')\n  const noProxyList = noProxy.split(',')\n\n  // iterate through the noProxyList until it finds a match.\n  return noProxyList.map(parseNoProxyZone).some((noProxyZone) => {\n    const isMatchedAt = hostname.indexOf(noProxyZone.hostname)\n    const hostnameMatched =\n      isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length\n\n    if (noProxyZone.hasPort) {\n      return port === noProxyZone.port && hostnameMatched\n    }\n\n    return hostnameMatched\n  })\n}\n\nfunction getProxyFromUri(uri: UrlWithStringQuery): string | null {\n  // Decide the proper request proxy to use based on the request URI object and the\n  // environmental variables (NO_PROXY, HTTP_PROXY, etc.)\n  // respect NO_PROXY environment variables (see: http://lynx.isc.org/current/breakout/lynx_help/keystrokes/environments.html)\n  const noProxy = process.env['NO_PROXY'] || process.env['no_proxy'] || ''\n\n  // if the noProxy is a wildcard then return null\n  if (noProxy === '*') {\n    return null\n  }\n\n  // if the noProxy is not empty and the uri is found return null\n  if (noProxy !== '' && uriInNoProxy(uri, noProxy)) {\n    return null\n  }\n\n  // Check for HTTP or HTTPS Proxy in environment, else default to null\n  if (uri.protocol === 'http:') {\n    return process.env['HTTP_PROXY'] || process.env['http_proxy'] || null\n  }\n\n  if (uri.protocol === 'https:') {\n    return (\n      process.env['HTTPS_PROXY'] ||\n      process.env['https_proxy'] ||\n      process.env['HTTP_PROXY'] ||\n      process.env['http_proxy'] ||\n      null\n    )\n  }\n\n  // if none of that works, return null\n  // (What uri protocol are you using then?)\n  return null\n}\n\nfunction getHostFromUri(uri: UrlWithStringQuery) {\n  let host = uri.host\n\n  // Drop :port suffix from Host header if known protocol.\n  if (uri.port) {\n    if (\n      (uri.port === '80' && uri.protocol === 'http:') ||\n      (uri.port === '443' && uri.protocol === 'https:')\n    ) {\n      host = uri.hostname\n    }\n  }\n\n  return host\n}\n\nfunction getHostHeaderWithPort(uri: UrlWithStringQuery) {\n  const port = uri.port || (uri.protocol === 'https:' ? '443' : '80')\n  return `${uri.hostname}:${port}`\n}\n\nexport function rewriteUriForProxy(\n  reqOpts: RequestOptions & UrlWithStringQuery,\n  uri: UrlWithStringQuery,\n  proxy: UrlWithStringQuery | ProxyOptions,\n) {\n  const headers = reqOpts.headers || {}\n  const options = Object.assign({}, reqOpts, {headers})\n  headers.host = headers.host || getHostHeaderWithPort(uri)\n  options.protocol = proxy.protocol || options.protocol\n  options.hostname = (\n    proxy.host ||\n    ('hostname' in proxy && proxy.hostname) ||\n    options.hostname ||\n    ''\n  ).replace(/:\\d+/, '')\n  options.port = proxy.port ? `${proxy.port}` : options.port\n  options.host = getHostFromUri(Object.assign({}, uri, proxy))\n  options.href = `${options.protocol}//${options.host}${options.path}`\n  options.path = url.format(uri)\n  return options\n}\n\nexport function getProxyOptions(options: RequestOptions): UrlWithStringQuery | ProxyOptions | null {\n  const proxy =\n    typeof options.proxy === 'undefined' ? getProxyFromUri(url.parse(options.url)) : options.proxy\n\n  return typeof proxy === 'string' ? url.parse(proxy) : proxy || null\n}\n","/**\n * Code borrowed from https://github.com/request/request\n * Modified to be less request-specific, more functional\n * Apache License 2.0\n */\nimport * as tunnel from 'tunnel-agent'\nimport url from 'url'\n\nconst uriParts = [\n  'protocol',\n  'slashes',\n  'auth',\n  'host',\n  'port',\n  'hostname',\n  'hash',\n  'search',\n  'query',\n  'pathname',\n  'path',\n  'href',\n]\n\nconst defaultProxyHeaderWhiteList = [\n  'accept',\n  'accept-charset',\n  'accept-encoding',\n  'accept-language',\n  'accept-ranges',\n  'cache-control',\n  'content-encoding',\n  'content-language',\n  'content-location',\n  'content-md5',\n  'content-range',\n  'content-type',\n  'connection',\n  'date',\n  'expect',\n  'max-forwards',\n  'pragma',\n  'referer',\n  'te',\n  'user-agent',\n  'via',\n]\n\nconst defaultProxyHeaderExclusiveList = ['proxy-authorization']\n\nexport function shouldEnable(options: any) {\n  // Tunnel HTTPS by default. Allow the user to override this setting.\n\n  // If user has specified a specific tunnel override...\n  if (typeof options.tunnel !== 'undefined') {\n    return Boolean(options.tunnel)\n  }\n\n  // If the destination is HTTPS, tunnel.\n  const uri = url.parse(options.url)\n  if (uri.protocol === 'https:') {\n    return true\n  }\n\n  // Otherwise, do not use tunnel.\n  return false\n}\n\nexport function applyAgent(opts: any = {}, proxy: any) {\n  const options = Object.assign({}, opts)\n\n  // Setup proxy header exclusive list and whitelist\n  const proxyHeaderWhiteList = defaultProxyHeaderWhiteList\n    .concat(options.proxyHeaderWhiteList || [])\n    .map((header) => header.toLowerCase())\n\n  const proxyHeaderExclusiveList = defaultProxyHeaderExclusiveList\n    .concat(options.proxyHeaderExclusiveList || [])\n    .map((header) => header.toLowerCase())\n\n  // Get the headers we should send to the proxy\n  const proxyHeaders = getAllowedProxyHeaders(options.headers, proxyHeaderWhiteList)\n  proxyHeaders.host = constructProxyHost(options)\n\n  // Reduce headers to the ones not exclusive for the proxy\n  options.headers = Object.keys(options.headers || {}).reduce((headers, header) => {\n    const isAllowed = proxyHeaderExclusiveList.indexOf(header.toLowerCase()) === -1\n    if (isAllowed) {\n      headers[header] = options.headers[header]\n    }\n\n    return headers\n  }, {} as any)\n\n  const tunnelFn = getTunnelFn(options, proxy)\n  const tunnelOptions = constructTunnelOptions(options, proxy, proxyHeaders)\n  options.agent = tunnelFn(tunnelOptions)\n\n  return options\n}\n\nfunction getTunnelFn(options: any, proxy: any) {\n  const uri = getUriParts(options)\n  const tunnelFnName = constructTunnelFnName(uri, proxy)\n  return tunnel[tunnelFnName]\n}\n\nfunction getUriParts(options: any) {\n  return uriParts.reduce((uri, part) => {\n    uri[part] = options[part]\n    return uri\n  }, {} as any)\n}\n\ntype UriProtocol = `http` | `https`\ntype ProxyProtocol = `Http` | `Https`\nfunction constructTunnelFnName(uri: any, proxy: any): `${UriProtocol}Over${ProxyProtocol}` {\n  const uriProtocol = uri.protocol === 'https:' ? 'https' : 'http'\n  const proxyProtocol = proxy.protocol === 'https:' ? 'Https' : 'Http'\n  return `${uriProtocol}Over${proxyProtocol}`\n}\n\nfunction constructProxyHost(uri: any) {\n  const port = uri.port\n  const protocol = uri.protocol\n  let proxyHost = `${uri.hostname}:`\n\n  if (port) {\n    proxyHost += port\n  } else if (protocol === 'https:') {\n    proxyHost += '443'\n  } else {\n    proxyHost += '80'\n  }\n\n  return proxyHost\n}\n\nfunction getAllowedProxyHeaders(headers: any, whiteList: any): any {\n  return Object.keys(headers)\n    .filter((header) => whiteList.indexOf(header.toLowerCase()) !== -1)\n    .reduce((set: any, header: any) => {\n      set[header] = headers[header]\n      return set\n    }, {})\n}\n\nfunction constructTunnelOptions(options: any, proxy: any, proxyHeaders: any) {\n  return {\n    proxy: {\n      host: proxy.hostname,\n      port: +proxy.port,\n      proxyAuth: proxy.auth,\n      headers: proxyHeaders,\n    },\n    headers: options.headers,\n    ca: options.ca,\n    cert: options.cert,\n    key: options.key,\n    passphrase: options.passphrase,\n    pfx: options.pfx,\n    ciphers: options.ciphers,\n    rejectUnauthorized: options.rejectUnauthorized,\n    secureOptions: options.secureOptions,\n    secureProtocol: options.secureProtocol,\n  }\n}\n","import decompressResponse from 'decompress-response'\nimport follow, {type FollowResponse, type RedirectableRequest} from 'follow-redirects'\nimport type {FinalizeNodeOptionsPayload, HttpRequest, MiddlewareResponse} from 'get-it'\nimport http from 'http'\nimport https from 'https'\nimport qs from 'querystring'\nimport {Readable, type Stream} from 'stream'\nimport url from 'url'\n\nimport type {RequestAdapter} from '../types'\nimport {lowerCaseHeaders} from '../util/lowerCaseHeaders'\nimport {progressStream} from '../util/progress-stream'\nimport {getProxyOptions, rewriteUriForProxy} from './node/proxy'\nimport {concat} from './node/simpleConcat'\nimport {timedOut} from './node/timedOut'\nimport * as tunneling from './node/tunnel'\n\n/**\n * Taken from:\n * https://github.com/sindresorhus/is-stream/blob/fb8caed475b4107cee3c22be3252a904020eb2d4/index.js#L3-L6\n */\nconst isStream = (stream: any): stream is Stream =>\n  stream !== null && typeof stream === 'object' && typeof stream.pipe === 'function'\n\n/** @public */\nexport const adapter: RequestAdapter = 'node'\n\nexport class NodeRequestError extends Error {\n  request: http.ClientRequest\n  code?: string | undefined\n\n  constructor(err: NodeJS.ErrnoException, req: any) {\n    super(err.message)\n    this.request = req\n    this.code = err.code\n  }\n}\n\n// Reduce a fully fledged node-style response object to\n// something that works in both browser and node environment\nconst reduceResponse = (\n  res: http.IncomingMessage,\n  remoteAddress: string | undefined,\n  reqUrl: string,\n  method: string,\n  body: any,\n): MiddlewareResponse => ({\n  body,\n  url: reqUrl,\n  method: method,\n  headers: res.headers,\n  statusCode: res.statusCode || 0,\n  statusMessage: res.statusMessage || '',\n  remoteAddress,\n})\n\nexport const httpRequester: HttpRequest = (context, cb) => {\n  const {options} = context\n  const uri = Object.assign({}, url.parse(options.url))\n\n  if (typeof fetch === 'function' && options.fetch) {\n    const controller = new AbortController()\n    const reqOpts = context.applyMiddleware('finalizeOptions', {\n      ...uri,\n      method: options.method,\n      headers: {\n        ...(typeof options.fetch === 'object' && options.fetch.headers\n          ? lowerCaseHeaders(options.fetch.headers)\n          : {}),\n        ...lowerCaseHeaders(options.headers),\n      },\n      maxRedirects: options.maxRedirects,\n    }) as FinalizeNodeOptionsPayload\n    const fetchOpts = {\n      credentials: options.withCredentials ? 'include' : 'omit',\n      ...(typeof options.fetch === 'object' ? options.fetch : {}),\n      method: reqOpts.method,\n      headers: reqOpts.headers,\n      body: options.body,\n      signal: controller.signal,\n    } satisfies RequestInit\n\n    // Allow middleware to inject a response, for instance in the case of caching or mocking\n    const injectedResponse = context.applyMiddleware('interceptRequest', undefined, {\n      adapter,\n      context,\n    })\n\n    // If middleware injected a response, treat it as we normally would and return it\n    // Do note that the injected response has to be reduced to a cross-environment friendly response\n    if (injectedResponse) {\n      const cbTimer = setTimeout(cb, 0, null, injectedResponse)\n      const cancel = () => clearTimeout(cbTimer)\n      return {abort: cancel}\n    }\n\n    const request = fetch(options.url, fetchOpts)\n\n    // Let middleware know we're about to do a request\n    context.applyMiddleware('onRequest', {options, adapter, request, context})\n\n    request\n      .then(async (res) => {\n        const body = options.rawBody ? res.body : await res.text()\n\n        const headers = {} as Record<string, string>\n        res.headers.forEach((value, key) => {\n          headers[key] = value\n        })\n\n        cb(null, {\n          body,\n          url: res.url,\n          method: options.method!,\n          headers,\n          statusCode: res.status,\n          statusMessage: res.statusText,\n        })\n      })\n      .catch((err) => {\n        if (err.name == 'AbortError') return\n        cb(err)\n      })\n\n    return {abort: () => controller.abort()}\n  }\n\n  const bodyType = isStream(options.body) ? 'stream' : typeof options.body\n  if (\n    bodyType !== 'undefined' &&\n    bodyType !== 'stream' &&\n    bodyType !== 'string' &&\n    !Buffer.isBuffer(options.body)\n  ) {\n    throw new Error(`Request body must be a string, buffer or stream, got ${bodyType}`)\n  }\n\n  const lengthHeader: any = {}\n  if (options.bodySize) {\n    lengthHeader['content-length'] = options.bodySize\n  } else if (options.body && bodyType !== 'stream') {\n    lengthHeader['content-length'] = Buffer.byteLength(options.body)\n  }\n\n  // Make sure callback is not called in the event of a cancellation\n  let aborted = false\n  const callback = (err: Error | null, res?: MiddlewareResponse) => !aborted && cb(err, res)\n  context.channels.abort.subscribe(() => {\n    aborted = true\n  })\n\n  // Create a reduced subset of options meant for the http.request() method\n  let reqOpts: any = Object.assign({}, uri, {\n    method: options.method,\n    headers: Object.assign({}, lowerCaseHeaders(options.headers), lengthHeader),\n    maxRedirects: options.maxRedirects,\n  })\n\n  // Figure out proxying/tunnel options\n  const proxy = getProxyOptions(options)\n  const tunnel = proxy && tunneling.shouldEnable(options)\n\n  // Allow middleware to inject a response, for instance in the case of caching or mocking\n  const injectedResponse = context.applyMiddleware('interceptRequest', undefined, {\n    adapter,\n    context,\n  })\n\n  // If middleware injected a response, treat it as we normally would and return it\n  // Do note that the injected response has to be reduced to a cross-environment friendly response\n  if (injectedResponse) {\n    const cbTimer = setImmediate(callback, null, injectedResponse)\n    const abort = () => clearImmediate(cbTimer)\n    return {abort}\n  }\n\n  // We're using the follow-redirects module to transparently follow redirects\n  if (options.maxRedirects !== 0) {\n    reqOpts.maxRedirects = options.maxRedirects || 5\n  }\n\n  // Apply currect options for proxy tunneling, if enabled\n  if (proxy && tunnel) {\n    reqOpts = tunneling.applyAgent(reqOpts, proxy)\n  } else if (proxy && !tunnel) {\n    reqOpts = rewriteUriForProxy(reqOpts, uri, proxy)\n  }\n\n  // Handle proxy authorization if present\n  if (!tunnel && proxy && proxy.auth && !reqOpts.headers['proxy-authorization']) {\n    const [username, password] =\n      typeof proxy.auth === 'string'\n        ? proxy.auth.split(':').map((item) => qs.unescape(item))\n        : [proxy.auth.username, proxy.auth.password]\n\n    const auth = Buffer.from(`${username}:${password}`, 'utf8')\n    const authBase64 = auth.toString('base64')\n    reqOpts.headers['proxy-authorization'] = `Basic ${authBase64}`\n  }\n\n  // Figure out transport (http/https, forwarding/non-forwarding agent)\n  const transport = getRequestTransport(reqOpts, proxy, tunnel)\n  if (typeof options.debug === 'function' && proxy) {\n    options.debug(\n      'Proxying using %s',\n      reqOpts.agent ? 'tunnel agent' : `${reqOpts.host}:${reqOpts.port}`,\n    )\n  }\n\n  // See if we should try to request a compressed response (and decompress on return)\n  const tryCompressed = reqOpts.method !== 'HEAD'\n  if (tryCompressed && !reqOpts.headers['accept-encoding'] && options.compress !== false) {\n    reqOpts.headers['accept-encoding'] =\n      // Workaround Bun not supporting brotli: https://github.com/oven-sh/bun/issues/267\n      typeof Bun !== 'undefined' ? 'gzip, deflate' : 'br, gzip, deflate'\n  }\n\n  let _res: http.IncomingMessage | undefined\n  const finalOptions = context.applyMiddleware(\n    'finalizeOptions',\n    reqOpts,\n  ) as FinalizeNodeOptionsPayload\n  const request = transport.request(finalOptions, (response) => {\n    const res = tryCompressed ? decompressResponse(response) : response\n    _res = res\n    const resStream = context.applyMiddleware('onHeaders', res, {\n      headers: response.headers,\n      adapter,\n      context,\n    })\n\n    // On redirects, `responseUrl` is set\n    const reqUrl = 'responseUrl' in response ? response.responseUrl : options.url\n    // Get the remote address from the socket, if available. After the stream is consumed, the socket might be closed, so we grab it here.\n    const remoteAddress = res.socket?.remoteAddress\n\n    if (options.stream) {\n      callback(null, reduceResponse(res, remoteAddress, reqUrl, reqOpts.method, resStream))\n      return\n    }\n\n    // Concatenate the response body, then parse the response with middlewares\n    concat(resStream, (err: any, data: any) => {\n      if (err) {\n        return callback(err)\n      }\n\n      const body = options.rawBody ? data : data.toString()\n      const reduced = reduceResponse(res, remoteAddress, reqUrl, reqOpts.method, body)\n      return callback(null, reduced)\n    })\n  })\n\n  function onError(err: NodeJS.ErrnoException) {\n    // HACK: If we have a socket error, and response has already been assigned this means\n    // that a response has already been sent. According to node.js docs, this is\n    // will result in the response erroring with an error code of 'ECONNRESET'.\n    // We first destroy the response, then the request, with the same error. This way the\n    // error is forwarded to both the response and the request.\n    // See the event order outlined here https://nodejs.org/api/http.html#httprequesturl-options-callback for how node.js handles the different scenarios.\n    if (_res) _res.destroy(err)\n    request.destroy(err)\n  }\n\n  request.once('socket', (socket: NodeJS.Socket) => {\n    socket.once('error', onError)\n    request.once('response', (response) => {\n      response.once('end', () => {\n        socket.removeListener('error', onError)\n      })\n    })\n  })\n\n  request.once('error', (err: NodeJS.ErrnoException) => {\n    if (_res) return\n    // The callback has already been invoked. Any error should be sent to the response.\n    callback(new NodeRequestError(err, request))\n  })\n\n  if (options.timeout) {\n    timedOut(request, options.timeout)\n  }\n\n  // Cheating a bit here; since we're not concerned about the \"bundle size\" in node,\n  // and modifying the body stream would be sorta tricky, we're just always going\n  // to put a progress stream in the middle here.\n  const {bodyStream, progress} = getProgressStream(options)\n\n  // Let middleware know we're about to do a request\n  context.applyMiddleware('onRequest', {options, adapter, request, context, progress})\n\n  if (bodyStream) {\n    bodyStream.pipe(request)\n  } else {\n    request.end(options.body)\n  }\n\n  return {abort: () => request.abort()}\n}\n\nfunction getProgressStream(options: any) {\n  if (!options.body) {\n    return {}\n  }\n\n  const bodyIsStream = isStream(options.body)\n  const length = options.bodySize || (bodyIsStream ? null : Buffer.byteLength(options.body))\n  if (!length) {\n    return bodyIsStream ? {bodyStream: options.body} : {}\n  }\n\n  const progress = progressStream({time: 32, length})\n  const bodyStream = bodyIsStream ? options.body : Readable.from(options.body)\n  return {bodyStream: bodyStream.pipe(progress), progress}\n}\n\nfunction getRequestTransport(\n  reqOpts: any,\n  proxy: any,\n  tunnel: any,\n): {\n  request: (\n    options: any,\n    callback: (response: http.IncomingMessage | (http.IncomingMessage & FollowResponse)) => void,\n  ) => http.ClientRequest | RedirectableRequest<http.ClientRequest, http.IncomingMessage>\n} {\n  const isHttpsRequest = reqOpts.protocol === 'https:'\n  const transports =\n    reqOpts.maxRedirects === 0\n      ? {http: http, https: https}\n      : {http: follow.http, https: follow.https}\n\n  if (!proxy || tunnel) {\n    return isHttpsRequest ? transports.https : transports.http\n  }\n\n  // Assume the proxy is an HTTPS proxy if port is 443, or if there is a\n  // `protocol` option set that starts with https\n  let isHttpsProxy = proxy.port === 443\n  if (proxy.protocol) {\n    isHttpsProxy = /^https:?/.test(proxy.protocol)\n  }\n\n  return isHttpsProxy ? transports.https : transports.http\n}\n","/*! simple-concat. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexport function concat(stream: any, cb: any) {\n  const chunks: any = []\n  stream.on('data', function (chunk: any) {\n    chunks.push(chunk)\n  })\n  stream.once('end', function () {\n    if (cb) cb(null, Buffer.concat(chunks))\n    cb = null\n  })\n  stream.once('error', function (err: any) {\n    if (cb) cb(err)\n    cb = null\n  })\n}\n","// Copied from `@sanity/timed-out`\n\nimport type {IncomingMessage} from 'node:http'\nimport type {Socket} from 'node:net'\n\nexport function timedOut(req: any, time: any) {\n  if (req.timeoutTimer) {\n    return req\n  }\n\n  const delays = isNaN(time) ? time : {socket: time, connect: time}\n  const hostHeader = req.getHeader('host')\n  const host = hostHeader ? ' to ' + hostHeader : ''\n\n  if (delays.connect !== undefined) {\n    req.timeoutTimer = setTimeout(function timeoutHandler() {\n      const e: NodeJS.ErrnoException = new Error('Connection timed out on request' + host)\n      e.code = 'ETIMEDOUT'\n      req.destroy(e)\n    }, delays.connect)\n  }\n\n  // Clear the connection timeout timer once a socket is assigned to the\n  // request and is connected.\n  req.on('socket', function assign(socket: Socket) {\n    // Socket may come from Agent pool and may be already connected.\n    if (!socket.connecting) {\n      connect(socket)\n      return\n    }\n\n    socket.once('connect', () => connect(socket))\n  })\n\n  function clear() {\n    if (req.timeoutTimer) {\n      clearTimeout(req.timeoutTimer)\n      req.timeoutTimer = null\n    }\n  }\n\n  function connect(socket: Socket) {\n    clear()\n\n    if (delays.socket !== undefined) {\n      const socketTimeoutHandler = () => {\n        const e: NodeJS.ErrnoException = new Error('Socket timed out on request' + host)\n        e.code = 'ESOCKETTIMEDOUT'\n        socket.destroy(e)\n      }\n\n      socket.setTimeout(delays.socket, socketTimeoutHandler)\n      req.once('response', (response: IncomingMessage) => {\n        response.once('end', () => {\n          socket.removeListener('timeout', socketTimeoutHandler)\n        })\n      })\n    }\n  }\n\n  return req.on('error', clear)\n}\n"],"names":["isReactNative","navigator","product","defaultOptions","timeout","decodeQueryParam","value","decodeURIComponent","replace","normalizeTimeout","time","connect","socket","delay","Number","isNaN","validUrl","lowerCaseHeaders","headers","Object","keys","reduce","acc","header","toLowerCase","tick","maxTick","timer","inc","progressStream","options","length","transferred","nextUpdate","Date","now","delta","speed","setInterval","unref","buffer","pointer","last","getSpeed","dist","resolution","size","top","btm","clear","clearInterval","speedometer","startTime","update","percentage","remaining","eta","runtime","emit","ended","Math","round","floor","tr","through","chunk","_enc","callback","len","onlength","newLength","on","stream","readable","Array","isArray","contentLength","parseInt","res","progress","formatHostname","hostname","parseNoProxyZone","zoneStr","zone","trim","zoneParts","split","port","hasPort","indexOf","uriParts","defaultProxyHeaderWhiteList","defaultProxyHeaderExclusiveList","isStream","pipe","adapter","NodeRequestError","Error","request","code","constructor","err","req","super","message","this","reduceResponse","remoteAddress","reqUrl","method","body","url","statusCode","statusMessage","exports","N","a","b","h","context","cb","uri","assign","parse","fetch","controller","AbortController","reqOpts","applyMiddleware","maxRedirects","fetchOpts","credentials","withCredentials","signal","injectedResponse","cbTimer","setTimeout","abort","clearTimeout","then","async","rawBody","text","forEach","key","status","statusText","catch","name","bodyType","Buffer","isBuffer","lengthHeader","bodySize","byteLength","aborted","channels","subscribe","proxy","noProxy","process","env","NO_PROXY","no_proxy","protocol","map","some","noProxyZone","isMatchedAt","hostnameMatched","uriInNoProxy","HTTP_PROXY","http_proxy","HTTPS_PROXY","https_proxy","getProxyFromUri","getProxyOptions","tunnel","tunneling.shouldEnable","setImmediate","clearImmediate","opts","proxyHeaderWhiteList","concat","proxyHeaderExclusiveList","proxyHeaders","whiteList","filter","set","host","proxyHost","constructProxyHost","tunnelFn","part","getUriParts","tunnelFnName","constructTunnelFnName","getTunnelFn","tunnelOptions","proxyAuth","auth","ca","cert","passphrase","pfx","ciphers","rejectUnauthorized","secureOptions","secureProtocol","constructTunnelOptions","agent","tunneling.applyAgent","getHostHeaderWithPort","getHostFromUri","href","path","format","rewriteUriForProxy","username","password","item","qs","unescape","authBase64","from","toString","transport","isHttpsRequest","transports","http","https","follow","isHttpsProxy","test","getRequestTransport","debug","tryCompressed","_res","compress","Bun","finalOptions","response","decompressResponse","resStream","responseUrl","chunks","push","once","data","reduced","onError","destroy","removeListener","timeoutTimer","delays","hostHeader","getHeader","socketTimeoutHandler","e","connecting","timedOut","bodyStream","bodyIsStream","Readable","getProgressStream","end","p","query","searchParams","qIndex","URLSearchParams","base","slice","params","pair","append","splitUrl","entries","v","search","toUpperCase"],"mappings":"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"}