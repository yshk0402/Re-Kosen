{"version":3,"file":"data.js","sources":["../../../../../admin/src/pages/EditView/utils/data.ts"],"sourcesContent":["import { createRulesEngine } from '@strapi/admin/strapi-admin';\nimport { generateNKeysBetween } from 'fractional-indexing';\nimport pipe from 'lodash/fp/pipe';\n\nimport { DOCUMENT_META_FIELDS } from '../../../constants/attributes';\n\nimport type { ComponentsDictionary, Document } from '../../../hooks/useDocument';\nimport type { Schema, UID } from '@strapi/types';\n\n/* -------------------------------------------------------------------------------------------------\n * traverseData\n * -----------------------------------------------------------------------------------------------*/\n\n// Make only attributes required since it's the only one Content History has\ntype PartialSchema = Partial<Schema.Schema> & Pick<Schema.Schema, 'attributes'>;\n\ntype Predicate = <TAttribute extends Schema.Attribute.AnyAttribute>(\n  attribute: TAttribute,\n  value: Schema.Attribute.Value<TAttribute>\n) => boolean;\ntype Transform = <TAttribute extends Schema.Attribute.AnyAttribute>(\n  value: any,\n  attribute: TAttribute\n) => any;\ntype AnyData = Omit<Document, 'id'>;\n\nconst BLOCK_LIST_ATTRIBUTE_KEYS = ['__component', '__temp_key__'];\n\n/**\n * @internal This function is used to traverse the data and transform the values.\n * Given a predicate function, it will transform the value (using the given transform function)\n * if the predicate returns true. If it finds that the attribute is a component or dynamiczone,\n * it will recursively traverse those data structures as well.\n *\n * It is possible to break the ContentManager by using this function incorrectly, for example,\n * if you transform a number into a string but the attribute type is a number, the ContentManager\n * will not be able to save the data and the Form will likely crash because the component it's\n * passing the data too won't succesfully be able to handle the value.\n */\nconst traverseData =\n  (predicate: Predicate, transform: Transform) =>\n  (schema: PartialSchema, components: ComponentsDictionary = {}) =>\n  (data: AnyData = {}) => {\n    const traverse = (datum: AnyData, attributes: Schema.Schema['attributes']) => {\n      return Object.entries(datum).reduce<AnyData>((acc, [key, value]) => {\n        const attribute = attributes[key];\n\n        /**\n         * If the attribute is a block list attribute, we don't want to transform it.\n         * We also don't want to transform null or undefined values.\n         */\n        if (BLOCK_LIST_ATTRIBUTE_KEYS.includes(key) || value === null || value === undefined) {\n          acc[key] = value;\n          return acc;\n        }\n\n        if (attribute.type === 'component') {\n          if (attribute.repeatable) {\n            const componentValue = (\n              predicate(attribute, value) ? transform(value, attribute) : value\n            ) as Schema.Attribute.Value<Schema.Attribute.Component<UID.Component, true>>;\n            acc[key] = componentValue.map((componentData) =>\n              traverse(componentData, components[attribute.component]?.attributes ?? {})\n            );\n          } else {\n            const componentValue = (\n              predicate(attribute, value) ? transform(value, attribute) : value\n            ) as Schema.Attribute.Value<Schema.Attribute.Component<UID.Component, false>>;\n\n            acc[key] = traverse(componentValue, components[attribute.component]?.attributes ?? {});\n          }\n        } else if (attribute.type === 'dynamiczone') {\n          const dynamicZoneValue = (\n            predicate(attribute, value) ? transform(value, attribute) : value\n          ) as Schema.Attribute.Value<Schema.Attribute.DynamicZone>;\n\n          acc[key] = dynamicZoneValue.map((componentData) =>\n            traverse(componentData, components[componentData.__component]?.attributes ?? {})\n          );\n        } else if (predicate(attribute, value)) {\n          acc[key] = transform(value, attribute);\n        } else {\n          acc[key] = value;\n        }\n\n        return acc;\n      }, {});\n    };\n\n    return traverse(data, schema.attributes);\n  };\n\n/* -------------------------------------------------------------------------------------------------\n * removeProhibitedFields\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal Removes all the fields that are not allowed.\n */\nconst removeProhibitedFields = (prohibitedFields: Schema.Attribute.Kind[]) =>\n  traverseData(\n    (attribute) => prohibitedFields.includes(attribute.type),\n    () => ''\n  );\n\n/* -------------------------------------------------------------------------------------------------\n * prepareRelations\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n * @description Sets all relation values to an empty array.\n */\nconst prepareRelations = traverseData(\n  (attribute) => attribute.type === 'relation',\n  () => ({\n    connect: [],\n    disconnect: [],\n  })\n);\n\n/* -------------------------------------------------------------------------------------------------\n * prepareTempKeys\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n * @description Adds a `__temp_key__` to each component and dynamiczone item. This gives us\n * a stable identifier regardless of its ids etc. that we can then use for drag and drop.\n */\nconst prepareTempKeys = traverseData(\n  (attribute) =>\n    (attribute.type === 'component' && attribute.repeatable) || attribute.type === 'dynamiczone',\n  (data) => {\n    if (Array.isArray(data) && data.length > 0) {\n      const keys = generateNKeysBetween(undefined, undefined, data.length);\n\n      return data.map((datum, index) => ({\n        ...datum,\n        __temp_key__: keys[index],\n      }));\n    }\n\n    return data;\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * removeFieldsThatDontExistOnSchema\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n * @description Fields that don't exist in the schema like createdAt etc. are only on the first level (not nested),\n * as such we don't need to traverse the components to remove them.\n */\nconst removeFieldsThatDontExistOnSchema = (schema: PartialSchema) => (data: AnyData) => {\n  const schemaKeys = Object.keys(schema.attributes);\n  const dataKeys = Object.keys(data);\n\n  const keysToRemove = dataKeys.filter((key) => !schemaKeys.includes(key));\n\n  const revisedData = [...keysToRemove, ...DOCUMENT_META_FIELDS].reduce((acc, key) => {\n    delete acc[key];\n\n    return acc;\n  }, structuredClone(data));\n\n  return revisedData;\n};\n\n/**\n * @internal\n * @description We need to remove null fields from the data-structure because it will pass it\n * to the specific inputs breaking them as most would prefer empty strings or `undefined` if\n * they're controlled / uncontrolled. However, Boolean fields should preserve null values.\n */\nconst removeNullValues = (schema: PartialSchema, components: ComponentsDictionary = {}) =>\n  traverseData(\n    (attribute, value) => value === null && attribute.type !== 'boolean',\n    () => undefined\n  )(schema, components);\n\n/* -------------------------------------------------------------------------------------------------\n * transformDocuments\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n * @description Takes a document data structure (this could be from the API or a default form structure)\n * and applies consistent data transformations to it. This is also used when we add new components to the\n * form to ensure the data is correctly prepared from their default state e.g. relations are set to an empty array.\n */\nconst transformDocument =\n  (schema: PartialSchema, components: ComponentsDictionary = {}) =>\n  (document: AnyData) => {\n    const transformations = pipe(\n      removeFieldsThatDontExistOnSchema(schema),\n      removeProhibitedFields(['password'])(schema, components),\n      removeNullValues(schema, components),\n      prepareRelations(schema, components),\n      prepareTempKeys(schema, components)\n    );\n\n    return transformations(document);\n  };\n\ntype HandleOptions = {\n  schema?: Schema.ContentType | Schema.Component;\n  initialValues?: AnyData;\n  components?: Record<string, Schema.Component>;\n};\n\ntype RemovedFieldPath = string;\n\n/**\n * @internal\n * @description Finds the initial value for a component or dynamic zone item (based on its __temp_key__ and not its index).\n * @param initialValue - The initial values object.\n * @param item - The item to find the initial value for.\n * @returns The initial value for the item.\n */\nconst getItemInitialValue = (initialValue: AnyData, item: AnyData) => {\n  if (initialValue && Array.isArray(initialValue)) {\n    const matchingInitialItem = initialValue.find(\n      (initialItem) => initialItem.__temp_key__ === item.__temp_key__\n    );\n    if (matchingInitialItem) {\n      return matchingInitialItem;\n    }\n  }\n  return {};\n};\n\n/**\n * @internal\n * @description Collects paths of attributes that should be removed based on visibility conditions.\n * This function only evaluates conditions.visible (JSON Logic), not the visible boolean property.\n *\n * @param data - The data object to evaluate\n * @param schema - The content type schema\n * @param components - Dictionary of component schemas\n * @param path - Current path in the data structure (for nested components/dynamiczones)\n * @returns Array of field paths that should be removed\n */\nconst collectInvisibleAttributes = (\n  data: AnyData,\n  schema: Schema.ContentType | Schema.Component | undefined,\n  components: Record<string, Schema.Component>,\n  path: string[] = []\n): RemovedFieldPath[] => {\n  if (!schema?.attributes) return [];\n\n  const rulesEngine = createRulesEngine();\n  const removedPaths: RemovedFieldPath[] = [];\n  const evaluatedData: AnyData = {};\n\n  for (const [attrName, attrDef] of Object.entries(schema.attributes)) {\n    const fullPath = [...path, attrName].join('.');\n\n    // Skip fields with visible: false - they're managed by backend\n    if ('visible' in attrDef && attrDef.visible === false) {\n      continue;\n    }\n\n    const condition = attrDef?.conditions?.visible;\n    const isVisible = condition\n      ? rulesEngine.evaluate(condition, { ...data, ...evaluatedData })\n      : true;\n\n    if (!isVisible) {\n      removedPaths.push(fullPath);\n      continue;\n    }\n\n    // Track this field for future condition evaluations\n    if (attrName in data) {\n      evaluatedData[attrName] = data[attrName];\n    }\n\n    // Recursively process components\n    if (attrDef.type === 'component') {\n      const compSchema = components[attrDef.component];\n      const value = data[attrName];\n\n      if (attrDef.repeatable && Array.isArray(value)) {\n        value.forEach((item) => {\n          const nestedPaths = collectInvisibleAttributes(item, compSchema, components, [\n            ...path,\n            `${attrName}[${item.__temp_key__}]`,\n          ]);\n          removedPaths.push(...nestedPaths);\n        });\n      } else if (value && typeof value === 'object') {\n        const nestedPaths = collectInvisibleAttributes(value, compSchema, components, [\n          ...path,\n          attrName,\n        ]);\n        removedPaths.push(...nestedPaths);\n      }\n    }\n\n    // Recursively process dynamic zones\n    if (attrDef.type === 'dynamiczone' && Array.isArray(data[attrName])) {\n      data[attrName].forEach((dzItem: AnyData) => {\n        const compUID = dzItem?.__component;\n        const compSchema = components[compUID];\n        const nestedPaths = collectInvisibleAttributes(dzItem, compSchema, components, [\n          ...path,\n          `${attrName}[${dzItem.__temp_key__}]`,\n        ]);\n        removedPaths.push(...nestedPaths);\n      });\n    }\n  }\n\n  return removedPaths;\n};\n\n/**\n * @internal\n * @description Removes attributes from data based on the list of paths to remove.\n * Preserves fields with visible: false from data or initialValues.\n *\n * @param data - The data object to filter\n * @param initialValues - Initial values to fall back to\n * @param schema - The content type schema\n * @param components - Dictionary of component schemas\n * @param removedPaths - Array of field paths to remove\n * @param currentPath - Current path in the data structure\n * @returns Filtered data object\n */\nconst filterDataByRemovedPaths = (\n  data: AnyData,\n  initialValues: AnyData,\n  schema: Schema.ContentType | Schema.Component | undefined,\n  components: Record<string, Schema.Component>,\n  removedPaths: RemovedFieldPath[],\n  currentPath: string[] = []\n): AnyData => {\n  if (!schema?.attributes) return data;\n\n  const result: AnyData = {};\n\n  for (const [attrName, attrDef] of Object.entries(schema.attributes)) {\n    const fullPath = [...currentPath, attrName].join('.');\n\n    // Check if this field should be removed\n    if (removedPaths.includes(fullPath)) {\n      continue;\n    }\n\n    // Handle fields with visible: false - preserve from data or initialValues\n    if ('visible' in attrDef && attrDef.visible === false) {\n      const userProvided = Object.hasOwn(data, attrName);\n      if (userProvided) {\n        result[attrName] = data[attrName];\n      } else if (attrName in initialValues) {\n        result[attrName] = initialValues[attrName];\n      }\n      continue;\n    }\n\n    const userProvided = Object.hasOwn(data, attrName);\n    const currentValue = userProvided ? data[attrName] : undefined;\n    const initialValue = initialValues?.[attrName];\n\n    // Handle components\n    if (attrDef.type === 'component') {\n      const compSchema = components[attrDef.component];\n      const value = currentValue === undefined ? initialValue : currentValue;\n\n      if (!value) {\n        result[attrName] = attrDef.repeatable ? [] : null;\n        continue;\n      }\n\n      if (attrDef.repeatable && Array.isArray(value)) {\n        result[attrName] = value.map((item) => {\n          const componentInitialValue = getItemInitialValue(initialValue, item);\n          return filterDataByRemovedPaths(\n            item,\n            componentInitialValue,\n            compSchema,\n            components,\n            removedPaths,\n            [...currentPath, `${attrName}[${item.__temp_key__}]`]\n          );\n        });\n      } else {\n        result[attrName] = filterDataByRemovedPaths(\n          value,\n          initialValue ?? {},\n          compSchema,\n          components,\n          removedPaths,\n          [...currentPath, attrName]\n        );\n      }\n\n      continue;\n    }\n\n    // Handle dynamic zones\n    if (attrDef.type === 'dynamiczone') {\n      if (!Array.isArray(currentValue)) {\n        result[attrName] = [];\n        continue;\n      }\n\n      result[attrName] = currentValue.map((dzItem) => {\n        const compUID = dzItem?.__component;\n        const compSchema = components[compUID];\n        const componentInitialValue = getItemInitialValue(initialValue, dzItem);\n\n        const cleaned = filterDataByRemovedPaths(\n          dzItem,\n          componentInitialValue,\n          compSchema,\n          components,\n          removedPaths,\n          [...currentPath, `${attrName}[${dzItem.__temp_key__}]`]\n        );\n\n        // For newly created components, ensure id is undefined (in case of reordering)\n        const processedItem =\n          dzItem.id === undefined || dzItem.id === null\n            ? { __component: compUID, ...cleaned, id: undefined }\n            : { __component: compUID, ...cleaned };\n\n        return processedItem;\n      });\n\n      continue;\n    }\n\n    // Regular fields - preserve from data or initialValues\n    if (currentValue !== undefined) {\n      result[attrName] = currentValue;\n    } else if (initialValue !== undefined) {\n      result[attrName] = initialValue;\n    }\n  }\n\n  // Pass through any fields from data that aren't in the schema\n  for (const [key, value] of Object.entries(data)) {\n    if (!(key in result) && !(key in (schema?.attributes || {}))) {\n      result[key] = value;\n    }\n  }\n\n  return result;\n};\n\n/**\n * Removes values from the data object if their corresponding attribute has a\n * visibility condition that evaluates to false.\n *\n * @param data - The data object to filter based on visibility\n * @param options - Schema, initialValues, and components\n * @returns Object with filtered data and list of removed attribute paths\n */\nconst handleInvisibleAttributes = (\n  data: AnyData,\n  { schema, initialValues = {}, components = {} }: HandleOptions\n): {\n  data: AnyData;\n  removedAttributes: RemovedFieldPath[];\n} => {\n  if (!schema?.attributes) return { data, removedAttributes: [] };\n\n  const removedAttributes = collectInvisibleAttributes(data, schema, components);\n\n  const filteredData = filterDataByRemovedPaths(\n    data,\n    initialValues,\n    schema,\n    components,\n    removedAttributes\n  );\n\n  return {\n    data: filteredData,\n    removedAttributes,\n  };\n};\n\nexport {\n  removeProhibitedFields,\n  prepareRelations,\n  prepareTempKeys,\n  removeFieldsThatDontExistOnSchema,\n  transformDocument,\n  handleInvisibleAttributes,\n};\nexport type { AnyData };\n"],"names":["BLOCK_LIST_ATTRIBUTE_KEYS","traverseData","predicate","transform","schema","components","data","traverse","datum","attributes","Object","entries","reduce","acc","key","value","attribute","includes","undefined","type","repeatable","componentValue","map","componentData","component","dynamicZoneValue","__component","removeProhibitedFields","prohibitedFields","prepareRelations","connect","disconnect","prepareTempKeys","Array","isArray","length","keys","generateNKeysBetween","index","__temp_key__","removeFieldsThatDontExistOnSchema","schemaKeys","dataKeys","keysToRemove","filter","revisedData","DOCUMENT_META_FIELDS","structuredClone","removeNullValues","transformDocument","document","transformations","pipe","getItemInitialValue","initialValue","item","matchingInitialItem","find","initialItem","collectInvisibleAttributes","path","rulesEngine","createRulesEngine","removedPaths","evaluatedData","attrName","attrDef","fullPath","join","visible","condition","conditions","isVisible","evaluate","push","compSchema","forEach","nestedPaths","dzItem","compUID","filterDataByRemovedPaths","initialValues","currentPath","result","userProvided","hasOwn","currentValue","componentInitialValue","cleaned","processedItem","id","handleInvisibleAttributes","removedAttributes","filteredData"],"mappings":"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"}