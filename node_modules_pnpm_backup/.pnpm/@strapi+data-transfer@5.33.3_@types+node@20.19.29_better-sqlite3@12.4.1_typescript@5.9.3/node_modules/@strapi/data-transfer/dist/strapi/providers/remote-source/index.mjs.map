{"version":3,"file":"index.mjs","sources":["../../../../src/strapi/providers/remote-source/index.ts"],"sourcesContent":["import { PassThrough, Readable, Writable } from 'stream';\nimport type { Struct, Utils } from '@strapi/types';\nimport { WebSocket } from 'ws';\nimport { castArray } from 'lodash/fp';\n\nimport type {\n  IAsset,\n  IMetadata,\n  ISourceProvider,\n  ISourceProviderTransferResults,\n  MaybePromise,\n  Protocol,\n  ProviderType,\n  TransferStage,\n} from '../../../../types';\nimport type { IDiagnosticReporter } from '../../../utils/diagnostic';\nimport { Client, Server, Auth } from '../../../../types/remote/protocol';\nimport { ProviderTransferError, ProviderValidationError } from '../../../errors/providers';\nimport { TRANSFER_PATH } from '../../remote/constants';\nimport { ILocalStrapiSourceProviderOptions } from '../local-source';\nimport { createDispatcher, connectToWebsocket, trimTrailingSlash } from '../utils';\n\nexport interface IRemoteStrapiSourceProviderOptions extends ILocalStrapiSourceProviderOptions {\n  url: URL; // the url of the remote Strapi admin\n  auth?: Auth.ITransferTokenAuth;\n  retryMessageOptions?: {\n    retryMessageTimeout: number; // milliseconds to wait for a response from a message\n    retryMessageMaxRetries: number; // max number of retries for a message before aborting transfer\n  };\n  streamTimeout?: number; // milliseconds to wait between chunks of an asset before aborting the transfer\n}\n\ntype QueueableAction = Protocol.Client.TransferAssetFlow &\n  ({ action: 'stream' } | { action: 'end' });\n\nclass RemoteStrapiSourceProvider implements ISourceProvider {\n  name = 'source::remote-strapi';\n\n  type: ProviderType = 'source';\n\n  options: IRemoteStrapiSourceProviderOptions;\n\n  ws: WebSocket | null;\n\n  dispatcher: ReturnType<typeof createDispatcher> | null;\n\n  defaultOptions: Partial<IRemoteStrapiSourceProviderOptions> = {\n    streamTimeout: 15000,\n  };\n\n  constructor(options: IRemoteStrapiSourceProviderOptions) {\n    this.options = {\n      ...this.defaultOptions,\n      ...options,\n    };\n\n    this.ws = null;\n    this.dispatcher = null;\n  }\n\n  results?: ISourceProviderTransferResults | undefined;\n\n  #diagnostics?: IDiagnosticReporter;\n\n  async #createStageReadStream(stage: Exclude<TransferStage, 'schemas'>) {\n    const startResult = await this.#startStep(stage);\n\n    if (startResult instanceof Error) {\n      throw startResult;\n    }\n\n    const { id: processID } = startResult as { id: string };\n\n    const stream = new PassThrough({ objectMode: true });\n\n    const listener = async (raw: Buffer) => {\n      const parsed = JSON.parse(raw.toString());\n      // If not a message related to our transfer process, ignore it\n      if (!parsed.uuid || parsed?.data?.type !== 'transfer' || parsed?.data?.id !== processID) {\n        this.ws?.once('message', listener);\n        return;\n      }\n\n      const { uuid, data: message } = parsed;\n      const { ended, error, data } = message;\n\n      if (error) {\n        await this.#respond(uuid);\n        stream.destroy(error);\n        return;\n      }\n\n      if (ended) {\n        await this.#respond(uuid);\n        await this.#endStep(stage);\n\n        stream.end();\n        return;\n      }\n\n      // if we get a single items instead of a batch\n      for (const item of castArray(data)) {\n        stream.push(item);\n      }\n\n      this.ws?.once('message', listener);\n\n      await this.#respond(uuid);\n    };\n\n    this.ws?.once('message', listener);\n\n    return stream;\n  }\n\n  createEntitiesReadStream(): MaybePromise<Readable> {\n    return this.#createStageReadStream('entities');\n  }\n\n  createLinksReadStream(): MaybePromise<Readable> {\n    return this.#createStageReadStream('links');\n  }\n\n  writeAsync = <T>(stream: Writable, data: T) => {\n    return new Promise<void>((resolve, reject) => {\n      stream.write(data, (error) => {\n        if (error) {\n          reject(error);\n        }\n\n        resolve();\n      });\n    });\n  };\n\n  async createAssetsReadStream(): Promise<Readable> {\n    // Create the streams used to transfer the assets\n    const stream = await this.#createStageReadStream('assets');\n    const pass = new PassThrough({ objectMode: true });\n\n    // Init the asset map\n    const assets: {\n      // TODO: could we include filename in this for improved logging?\n      [assetID: string]: IAsset & {\n        stream: PassThrough;\n        queue: Array<QueueableAction>;\n        status: 'ok' | 'closed' | 'errored';\n        timeout?: NodeJS.Timeout;\n      };\n    } = {};\n\n    // Watch for stalled assets; if we don't receive a chunk within timeout, abort transfer\n    const resetTimeout = (assetID: string) => {\n      if (assets[assetID].timeout) {\n        clearTimeout(assets[assetID].timeout);\n      }\n      assets[assetID].timeout = setTimeout(() => {\n        this.#reportInfo(`Asset ${assetID} transfer stalled, aborting.`);\n        assets[assetID].status = 'errored';\n        assets[assetID].stream.destroy(new Error(`Asset ${assetID} transfer timed out`));\n      }, this.options.streamTimeout);\n    };\n\n    stream\n      /**\n       * Process a payload of many transfer assets and performs the following tasks:\n       * - Start: creates a stream for new assets.\n       * - Stream: writes asset chunks to the asset's stream.\n       * - End: closes the stream after the asset s transferred and cleanup related resources.\n       */\n      .on('data', async (payload: Protocol.Client.TransferAssetFlow[]) => {\n        for (const item of payload) {\n          const { action, assetID } = item;\n\n          // Creates the stream to send the incoming asset through\n          if (action === 'start') {\n            // if a transfer has already been started for the same asset ID, something is wrong\n            if (assets[assetID]) {\n              throw new Error(`Asset ${assetID} already started`);\n            }\n\n            this.#reportInfo(`Asset ${assetID} starting`);\n            // Register the asset\n            assets[assetID] = {\n              ...item.data,\n              stream: new PassThrough(),\n              status: 'ok',\n              queue: [],\n            };\n\n            resetTimeout(assetID);\n\n            // Connect the individual asset stream to the main asset stage stream\n            // Note: nothing is transferred until data chunks are fed to the asset stream\n            await this.writeAsync(pass, assets[assetID]);\n          }\n\n          // Writes the asset's data chunks to their corresponding stream\n          // \"end\" is considered a chunk, but it's not a data chunk, it's a control message\n          // That is done so that we don't complicate the already complicated async processing of the queue\n          else if (action === 'stream' || action === 'end') {\n            // If the asset hasn't been registered, or if it's been closed already, something is wrong\n            if (!assets[assetID]) {\n              throw new Error(`No id matching ${assetID} for stream action`);\n            }\n\n            // On every action, reset the timeout timer\n            if (action === 'stream') {\n              resetTimeout(assetID);\n            } else {\n              clearTimeout(assets[assetID].timeout);\n            }\n\n            if (assets[assetID].status === 'closed') {\n              throw new Error(`Asset ${assetID} is closed`);\n            }\n\n            assets[assetID].queue.push(item);\n          }\n        }\n\n        // each new payload will start new processQueue calls, which may cause some extra calls\n        // it's essentially saying \"start processing this asset again, I added more data to the queue\"\n        for (const assetID in assets) {\n          if (Object.prototype.hasOwnProperty.call(assets, assetID)) {\n            const asset = assets[assetID];\n            if (asset.queue?.length > 0) {\n              await processQueue(assetID);\n            }\n          }\n        }\n      })\n      .on('close', () => {\n        pass.end();\n      });\n\n    /**\n     * Start processing the queue for a given assetID\n     *\n     * Even though this is a loop that attempts to process the entire queue, it is safe to call this more than once\n     * for the same asset id because the queue is shared globally, the items are shifted off, and immediately written\n     */\n    const processQueue = async (id: string) => {\n      if (!assets[id]) {\n        throw new Error(`Failed to write asset chunk for \"${id}\". Asset not found.`);\n      }\n\n      const asset = assets[id];\n      const { status: currentStatus } = asset;\n\n      if (['closed', 'errored'].includes(currentStatus)) {\n        throw new Error(\n          `Failed to write asset chunk for \"${id}\". The asset is currently \"${currentStatus}\"`\n        );\n      }\n\n      while (asset.queue.length > 0) {\n        const data = asset.queue.shift();\n\n        if (!data) {\n          throw new Error(`Invalid chunk found for ${id}`);\n        }\n\n        try {\n          // if this is an end chunk, close the asset stream\n          if (data.action === 'end') {\n            this.#reportInfo(`Ending asset stream for ${id}`);\n            await closeAssetStream(id);\n            break; // Exit the loop after closing the stream\n          }\n\n          // Save the current chunk\n          await writeChunkToStream(id, data);\n        } catch {\n          if (!assets[id]) {\n            throw new Error(`No id matching ${id} for writeAssetChunk`);\n          }\n        }\n      }\n    };\n\n    /**\n     * Writes a chunk of data to the asset's stream.\n     *\n     * Only check if the targeted asset exists, no other validation is done.\n     */\n    const writeChunkToStream = async (id: string, data: unknown) => {\n      const asset = assets[id];\n\n      if (!asset) {\n        throw new Error(`Failed to write asset chunk for \"${id}\". Asset not found.`);\n      }\n\n      const rawBuffer = data as { type: 'Buffer'; data: Uint8Array };\n      const chunk = Buffer.from(rawBuffer.data);\n\n      await this.writeAsync(asset.stream, chunk);\n    };\n\n    /**\n     * Closes the asset stream associated with the given ID.\n     *\n     * It deletes the stream for the asset upon successful closure.\n     */\n    const closeAssetStream = async (id: string) => {\n      if (!assets[id]) {\n        throw new Error(`Failed to close asset \"${id}\". Asset not found.`);\n      }\n\n      assets[id].status = 'closed';\n\n      await new Promise<void>((resolve, reject) => {\n        const { stream } = assets[id];\n\n        stream\n          .on('close', () => {\n            resolve();\n          })\n          .on('error', (e) => {\n            assets[id].status = 'errored';\n            reject(new Error(`Failed to close asset \"${id}\". Asset stream error: ${e.toString()}`));\n          })\n          .end();\n      });\n    };\n\n    return pass;\n  }\n\n  createConfigurationReadStream(): MaybePromise<Readable> {\n    return this.#createStageReadStream('configuration');\n  }\n\n  async getMetadata(): Promise<IMetadata | null> {\n    const metadata = await this.dispatcher?.dispatchTransferAction<IMetadata>('getMetadata');\n\n    return metadata ?? null;\n  }\n\n  assertValidProtocol(url: URL) {\n    const validProtocols = ['https:', 'http:'];\n\n    if (!validProtocols.includes(url.protocol)) {\n      throw new ProviderValidationError(`Invalid protocol \"${url.protocol}\"`, {\n        check: 'url',\n        details: {\n          protocol: url.protocol,\n          validProtocols,\n        },\n      });\n    }\n  }\n\n  async initTransfer(): Promise<string> {\n    const query = this.dispatcher?.dispatchCommand({\n      command: 'init',\n    });\n\n    const res = (await query) as Server.Payload<Server.InitMessage>;\n\n    if (!res?.transferID) {\n      throw new ProviderTransferError('Init failed, invalid response from the server');\n    }\n\n    return res.transferID;\n  }\n\n  #reportInfo(message: string) {\n    this.#diagnostics?.report({\n      details: {\n        createdAt: new Date(),\n        message,\n        origin: 'remote-source-provider',\n      },\n      kind: 'info',\n    });\n  }\n\n  async bootstrap(diagnostics?: IDiagnosticReporter): Promise<void> {\n    this.#diagnostics = diagnostics;\n    const { url, auth } = this.options;\n    let ws: WebSocket;\n    this.assertValidProtocol(url);\n    const wsProtocol = url.protocol === 'https:' ? 'wss:' : 'ws:';\n    const wsUrl = `${wsProtocol}//${url.host}${trimTrailingSlash(\n      url.pathname\n    )}${TRANSFER_PATH}/pull`;\n\n    this.#reportInfo('establishing websocket connection');\n    // No auth defined, trying public access for transfer\n    if (!auth) {\n      ws = await connectToWebsocket(wsUrl, undefined, this.#diagnostics);\n    }\n\n    // Common token auth, this should be the main auth method\n    else if (auth.type === 'token') {\n      const headers = { Authorization: `Bearer ${auth.token}` };\n      ws = await connectToWebsocket(wsUrl, { headers }, this.#diagnostics);\n    }\n\n    // Invalid auth method provided\n    else {\n      throw new ProviderValidationError('Auth method not available', {\n        check: 'auth.type',\n        details: {\n          auth: auth.type,\n        },\n      });\n    }\n\n    this.#reportInfo('established websocket connection');\n    this.ws = ws;\n    const { retryMessageOptions } = this.options;\n\n    this.#reportInfo('creating dispatcher');\n    this.dispatcher = createDispatcher(this.ws, retryMessageOptions, (message: string) =>\n      this.#reportInfo(message)\n    );\n    this.#reportInfo('creating dispatcher');\n\n    this.#reportInfo('initialize transfer');\n    const transferID = await this.initTransfer();\n    this.#reportInfo(`initialized transfer ${transferID}`);\n\n    this.dispatcher.setTransferProperties({ id: transferID, kind: 'pull' });\n    await this.dispatcher.dispatchTransferAction('bootstrap');\n  }\n\n  async close() {\n    await this.dispatcher?.dispatchTransferAction('close');\n\n    await new Promise<void>((resolve) => {\n      const { ws } = this;\n\n      if (!ws || ws.CLOSED) {\n        resolve();\n        return;\n      }\n\n      ws.on('close', () => resolve()).close();\n    });\n  }\n\n  async getSchemas() {\n    const schemas =\n      await this.dispatcher?.dispatchTransferAction<Utils.String.Dict<Struct.Schema>>('getSchemas');\n\n    return schemas ?? null;\n  }\n\n  async #startStep<T extends Client.TransferPullStep>(step: T) {\n    try {\n      return await this.dispatcher?.dispatchTransferStep({ action: 'start', step });\n    } catch (e) {\n      if (e instanceof Error) {\n        return e;\n      }\n\n      if (typeof e === 'string') {\n        return new ProviderTransferError(e);\n      }\n\n      return new ProviderTransferError('Unexpected error');\n    }\n  }\n\n  async #respond(uuid: string) {\n    return new Promise((resolve, reject) => {\n      this.ws?.send(JSON.stringify({ uuid }), (e) => {\n        if (e) {\n          reject(e);\n        } else {\n          resolve(e);\n        }\n      });\n    });\n  }\n\n  async #endStep<T extends Client.TransferPullStep>(step: T) {\n    try {\n      await this.dispatcher?.dispatchTransferStep({ action: 'end', step });\n    } catch (e) {\n      if (e instanceof Error) {\n        return e;\n      }\n\n      if (typeof e === 'string') {\n        return new ProviderTransferError(e);\n      }\n\n      return new ProviderTransferError('Unexpected error');\n    }\n\n    return null;\n  }\n}\n\nexport const createRemoteStrapiSourceProvider = (options: IRemoteStrapiSourceProviderOptions) => {\n  return new RemoteStrapiSourceProvider(options);\n};\n"],"names":["RemoteStrapiSourceProvider","createEntitiesReadStream","createLinksReadStream","createAssetsReadStream","stream","pass","PassThrough","objectMode","assets","resetTimeout","assetID","timeout","clearTimeout","setTimeout","status","destroy","Error","options","streamTimeout","on","payload","item","action","data","queue","writeAsync","push","Object","prototype","hasOwnProperty","call","asset","length","processQueue","end","id","currentStatus","includes","shift","closeAssetStream","writeChunkToStream","rawBuffer","chunk","Buffer","from","Promise","resolve","reject","e","toString","createConfigurationReadStream","getMetadata","metadata","dispatcher","dispatchTransferAction","assertValidProtocol","url","validProtocols","protocol","ProviderValidationError","check","details","initTransfer","query","dispatchCommand","command","res","transferID","ProviderTransferError","bootstrap","diagnostics","auth","ws","wsProtocol","wsUrl","host","trimTrailingSlash","pathname","TRANSFER_PATH","connectToWebsocket","undefined","type","headers","Authorization","token","retryMessageOptions","createDispatcher","message","setTransferProperties","kind","close","CLOSED","getSchemas","schemas","name","defaultOptions","write","error","stage","startResult","processID","listener","raw","parsed","JSON","parse","uuid","once","ended","castArray","report","createdAt","Date","origin","step","dispatchTransferStep","send","stringify","createRemoteStrapiSourceProvider"],"mappings":"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"}