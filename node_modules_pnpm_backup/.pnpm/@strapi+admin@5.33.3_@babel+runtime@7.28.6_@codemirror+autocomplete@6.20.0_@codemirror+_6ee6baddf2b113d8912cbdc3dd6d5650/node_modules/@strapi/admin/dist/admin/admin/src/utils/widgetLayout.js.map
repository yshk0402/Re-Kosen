{"version":3,"file":"widgetLayout.js","sources":["../../../../../admin/src/utils/widgetLayout.ts"],"sourcesContent":["/**\n *\n * Comprehensive utilities for widget layout operations including sizing, positioning, and layout calculations.\n *\n * Constraints:\n * - Maximum 3 widgets per row (since minimum widget width is 4 columns)\n * - Widget widths are snapped to discrete values: 4 (1/3), 6 (1/2), 8 (2/3), 12 (3/3)\n */\n\nimport type { Homepage } from '../../../shared/contracts/homepage';\nimport type { WidgetWithUID } from '../core/apis/Widgets';\n\nexport const WIDGET_SIZING = {\n  TOTAL_COLUMNS: 12,\n  MIN_WIDGET_WIDTH: 4,\n  DISCRETE_SIZES: [4, 6, 8, 12] as const,\n} as const;\n\nexport const WIDGET_DATA_ATTRIBUTES = {\n  WIDGET_ID: 'data-strapi-widget-id',\n  GRID_CONTAINER: 'data-strapi-grid-container',\n} as const;\n\nexport const getWidgetElement = (uid: string): HTMLElement | null => {\n  return document.querySelector(`[${WIDGET_DATA_ATTRIBUTES.WIDGET_ID}=\"${uid}\"]`);\n};\n\nexport const getWidgetGridContainer = (): HTMLElement | null => {\n  return document.querySelector(`[${WIDGET_DATA_ATTRIBUTES.GRID_CONTAINER}]`);\n};\n\nexport interface WidgetRow {\n  widgets: WidgetWithUID[];\n  totalWidth: number;\n  startIndex: number;\n  endIndex: number;\n}\n\n/**\n * Validates if a widget width is valid (within constraints)\n */\nexport const isValidWidgetWidth = (width: number): boolean => {\n  return width >= WIDGET_SIZING.MIN_WIDGET_WIDTH && width <= WIDGET_SIZING.TOTAL_COLUMNS;\n};\n\n/**\n * Validates if a resize operation is allowed between two widgets\n */\nexport const isValidResizeOperation = (leftWidth: number, rightWidth: number): boolean => {\n  // Check minimum size constraints\n  if (!isValidWidgetWidth(leftWidth) || !isValidWidgetWidth(rightWidth)) {\n    return false;\n  }\n\n  // Check if the total doesn't exceed row capacity\n  if (leftWidth + rightWidth > WIDGET_SIZING.TOTAL_COLUMNS) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Gets widget width with fallback to default value\n */\nexport const getWidgetWidth = (\n  columnWidths: Record<string, number>,\n  widgetId: string | undefined,\n  defaultWidth: number = 6\n): number => {\n  return widgetId ? columnWidths[widgetId] || defaultWidth : defaultWidth;\n};\n\n/**\n * Calculates the current row structure from widgets and their widths\n */\nexport const calculateWidgetRows = (\n  widgets: WidgetWithUID[],\n  columnWidths: Record<string, number>\n): WidgetRow[] => {\n  const rows: WidgetRow[] = [];\n  let currentRow: WidgetWithUID[] = [];\n  let currentRowWidth = 0;\n  let startIndex = 0;\n\n  widgets.forEach((widget, index) => {\n    const widgetWidth = getWidgetWidth(columnWidths, widget.uid);\n\n    // If adding this widget would exceed 12 columns, start a new row\n    if (currentRowWidth + widgetWidth > WIDGET_SIZING.TOTAL_COLUMNS) {\n      if (currentRow.length > 0) {\n        rows.push({\n          widgets: currentRow,\n          totalWidth: currentRowWidth,\n          startIndex,\n          endIndex: startIndex + currentRow.length - 1,\n        });\n      }\n      currentRow = [widget];\n      currentRowWidth = widgetWidth;\n      startIndex = index;\n    } else {\n      currentRow.push(widget);\n      currentRowWidth += widgetWidth;\n    }\n  });\n\n  // Add the last row if it has widgets\n  if (currentRow.length > 0) {\n    rows.push({\n      widgets: currentRow,\n      totalWidth: currentRowWidth,\n      startIndex,\n      endIndex: startIndex + currentRow.length - 1,\n    });\n  }\n\n  return rows;\n};\n\n/**\n * Calculates optimal layout for a specific row based on widget count\n * Only enforces constraints when necessary:\n * - 1 widget in row: must be 3/3 (12 columns)\n * - 3 widgets in row: must be 1/3+1/3+1/3 (4+4+4 columns)\n * - 2 widgets in row: preserves existing proportions or uses 1/2+1/2\n */\nexport const calculateOptimalLayoutForRow = (\n  widgetsInRow: WidgetWithUID[],\n  currentColumnWidths: Record<string, number>\n): Record<string, number> => {\n  const newWidths = { ...currentColumnWidths };\n  const widgetCount = widgetsInRow.length;\n\n  if (widgetCount === 1) {\n    // Single widget must take full width (12)\n    newWidths[widgetsInRow[0].uid] = 12;\n  } else if (widgetCount === 3) {\n    // Three widgets must be equal (4 + 4 + 4)\n    widgetsInRow.forEach((widget) => {\n      newWidths[widget.uid] = 4;\n    });\n  } else if (widgetCount === 2) {\n    // Two widgets can be flexible - preserve existing proportions or use 6 + 6\n    const currentWidths = widgetsInRow.map((widget) =>\n      getWidgetWidth(currentColumnWidths, widget.uid)\n    );\n    const totalWidth = currentWidths.reduce((sum, width) => sum + width, 0);\n\n    if (totalWidth === 12) {\n      // Row is already properly sized, preserve proportions\n      widgetsInRow.forEach((widget, index) => {\n        newWidths[widget.uid] = currentWidths[index];\n      });\n    } else {\n      // Row needs adjustment, use equal split\n      widgetsInRow.forEach((widget) => {\n        newWidths[widget.uid] = 6;\n      });\n    }\n  }\n\n  return newWidths;\n};\n\nexport const moveWidgetInArray = (\n  widgets: WidgetWithUID[],\n  widgetId: string,\n  insertIndex: number\n): WidgetWithUID[] => {\n  const currentIndex = widgets.findIndex((w) => w.uid === widgetId);\n  if (currentIndex === -1) return widgets;\n\n  // Remove widget from current position\n  const widgetsWithoutMoved = widgets.filter((w) => w.uid !== widgetId);\n\n  // Insert at new position (adjust index if moving forward)\n  const adjustedInsertIndex = insertIndex > currentIndex ? insertIndex - 1 : insertIndex;\n  const newWidgets = [...widgetsWithoutMoved];\n  newWidgets.splice(adjustedInsertIndex, 0, widgets[currentIndex]);\n\n  return newWidgets;\n};\n\nexport const findRowContainingWidget = (\n  widgetRows: WidgetRow[],\n  widgetId: string,\n  widgets: WidgetWithUID[]\n): WidgetRow | undefined => {\n  const widgetIndex = widgets.findIndex((w) => w.uid === widgetId);\n  if (widgetIndex === -1) return undefined;\n\n  return widgetRows.find((row) => widgetIndex >= row.startIndex && widgetIndex <= row.endIndex);\n};\n\nexport const resizeRowAfterRemoval = (\n  row: WidgetRow | undefined,\n  removedWidgetId: string,\n  currentWidths: Record<string, number>\n): Record<string, number> => {\n  if (!row) return currentWidths;\n\n  const remainingWidgets = row.widgets.filter((w) => w.uid !== removedWidgetId);\n  return calculateOptimalLayoutForRow(remainingWidgets, currentWidths);\n};\n\nexport const resizeRowAfterAddition = (\n  row: WidgetRow | undefined,\n  addedWidget: WidgetWithUID,\n  insertIndex: number,\n  currentWidths: Record<string, number>\n): Record<string, number> => {\n  if (!row) return currentWidths;\n\n  // Calculate the new widget arrangement for the target row\n  const targetRowWidgets = [...row.widgets];\n  const existingIndex = targetRowWidgets.findIndex((w) => w.uid === addedWidget.uid);\n\n  if (existingIndex !== -1) {\n    // Widget was already in this row, just reorder\n    targetRowWidgets.splice(existingIndex, 1);\n  }\n\n  // Insert at the new position within the row\n  let insertPosition = insertIndex - row.startIndex;\n\n  // If insertIndex is at the end of the row (row.endIndex + 1),\n  // insert at the end of the row instead of beyond it\n  if (insertIndex === row.endIndex + 1) {\n    insertPosition = row.widgets.length;\n  }\n\n  targetRowWidgets.splice(insertPosition, 0, addedWidget);\n\n  return calculateOptimalLayoutForRow(targetRowWidgets, currentWidths);\n};\n\nexport const isLastWidgetInRow = (\n  widgetIndex: number,\n  widgets: WidgetWithUID[],\n  columnWidths: Record<string, number>\n): boolean => {\n  if (widgetIndex >= widgets.length - 1) {\n    return true; // Last widget overall\n  }\n\n  let currentRowWidth = 0;\n\n  // Calculate the current row width by going through widgets from the start\n  for (let i = 0; i <= widgetIndex; i++) {\n    const widgetWidth = getWidgetWidth(columnWidths, widgets[i]?.uid);\n    if (currentRowWidth + widgetWidth > WIDGET_SIZING.TOTAL_COLUMNS) {\n      // This widget starts a new row, so the previous widget was the last in its row\n      currentRowWidth = widgetWidth;\n    } else {\n      currentRowWidth += widgetWidth;\n    }\n  }\n\n  // Check if the next widget would fit in the current row\n  const nextWidgetWidth = getWidgetWidth(columnWidths, widgets[widgetIndex + 1]?.uid);\n  return currentRowWidth + nextWidgetWidth > WIDGET_SIZING.TOTAL_COLUMNS;\n};\n\nexport const canResizeBetweenWidgets = (\n  leftWidgetId: string,\n  rightWidgetId: string,\n  columnWidths: Record<string, number>,\n  widgets: WidgetWithUID[]\n): boolean => {\n  const leftWidth = getWidgetWidth(columnWidths, leftWidgetId);\n  const rightWidth = getWidgetWidth(columnWidths, rightWidgetId);\n\n  // First check if the widgets are actually adjacent in the same row\n  const leftIndex = widgets.findIndex((w) => w.uid === leftWidgetId);\n  const rightIndex = widgets.findIndex((w) => w.uid === rightWidgetId);\n\n  // Widgets must be consecutive in the array and in the same row\n  if (rightIndex !== leftIndex + 1) {\n    return false;\n  }\n\n  // Check if they're in the same row by verifying the right widget isn't the first in a new row\n  if (isLastWidgetInRow(leftIndex, widgets, columnWidths)) {\n    return false; // Left widget is last in its row, so right widget starts a new row\n  }\n\n  // Check if either widget can be made smaller (must be > 4 columns)\n  // or if either widget can be made bigger (must be < 12 columns)\n  const canLeftShrink = leftWidth > WIDGET_SIZING.MIN_WIDGET_WIDTH;\n  const canRightShrink = rightWidth > WIDGET_SIZING.MIN_WIDGET_WIDTH;\n  const canLeftGrow = leftWidth < WIDGET_SIZING.TOTAL_COLUMNS;\n  const canRightGrow = rightWidth < WIDGET_SIZING.TOTAL_COLUMNS;\n\n  // Resizing is possible if either widget can shrink AND the other can grow\n  return (canLeftShrink && canRightGrow) || (canRightShrink && canLeftGrow);\n};\n\n/**\n * Filters widgets to only include those present in the homepage layout\n */\nexport const filterWidgetsByHomepageLayout = (\n  widgets: WidgetWithUID[],\n  homepageLayout: Homepage.Layout\n): WidgetWithUID[] => {\n  const createHomepageWidgetUidsSet = (homepageLayout: Homepage.Layout): Set<string> =>\n    new Set(homepageLayout.widgets.map((w) => w.uid));\n  const homepageWidgetUids = createHomepageWidgetUidsSet(homepageLayout);\n  return widgets.filter((widget) => homepageWidgetUids.has(widget.uid));\n};\n\n/**\n * Sorts widgets according to the homepage layout order\n */\nexport const sortWidgetsByHomepageLayout = (\n  widgets: WidgetWithUID[],\n  homepageLayout: Homepage.Layout\n): WidgetWithUID[] => {\n  const widgetOrderMap = new Map(\n    homepageLayout.widgets.map((widget, index) => [widget.uid, index])\n  );\n\n  return [...widgets].sort((a, b) => {\n    const aIndex = widgetOrderMap.get(a.uid) ?? Number.MAX_SAFE_INTEGER;\n    const bIndex = widgetOrderMap.get(b.uid) ?? Number.MAX_SAFE_INTEGER;\n    return aIndex - bIndex;\n  });\n};\n\n/**\n * Applies homepage layout to widgets (filters, sorts, and extracts widths)\n */\nexport const applyHomepageLayout = (\n  authorizedWidgets: WidgetWithUID[],\n  homepageLayout: Homepage.Layout\n): {\n  filteredWidgets: WidgetWithUID[];\n  widths: Record<string, number>;\n} => {\n  const layoutWidgets = filterWidgetsByHomepageLayout(authorizedWidgets, homepageLayout);\n  const sortedWidgets = sortWidgetsByHomepageLayout(layoutWidgets, homepageLayout);\n\n  // Extract widths from homepage layout\n  const widths: Record<string, number> = {};\n  homepageLayout.widgets.forEach(({ uid, width }) => {\n    widths[uid] = width;\n  });\n\n  return {\n    filteredWidgets: sortedWidgets,\n    widths,\n  };\n};\n\n/**\n * Creates default widget widths based on widget count\n * Even count: all widgets get width 6\n * Odd count: all widgets get width 6 except the last one which gets width 12\n */\nexport const createDefaultWidgetWidths = (widgets: WidgetWithUID[]): Record<string, number> => {\n  const defaultWidths: Record<string, number> = {};\n  const widgetCount = widgets.length;\n\n  if (widgetCount > 0) {\n    if (widgetCount % 2 === 0) {\n      widgets.forEach((widget) => {\n        defaultWidths[widget.uid] = 6;\n      });\n    } else {\n      widgets.forEach((widget, index) => {\n        defaultWidths[widget.uid] = index === widgetCount - 1 ? 12 : 6;\n      });\n    }\n  }\n\n  return defaultWidths;\n};\n"],"names":["WIDGET_SIZING","TOTAL_COLUMNS","MIN_WIDGET_WIDTH","DISCRETE_SIZES","WIDGET_DATA_ATTRIBUTES","WIDGET_ID","GRID_CONTAINER","getWidgetElement","uid","document","querySelector","getWidgetGridContainer","isValidWidgetWidth","width","isValidResizeOperation","leftWidth","rightWidth","getWidgetWidth","columnWidths","widgetId","defaultWidth","calculateWidgetRows","widgets","rows","currentRow","currentRowWidth","startIndex","forEach","widget","index","widgetWidth","length","push","totalWidth","endIndex","calculateOptimalLayoutForRow","widgetsInRow","currentColumnWidths","newWidths","widgetCount","currentWidths","map","reduce","sum","moveWidgetInArray","insertIndex","currentIndex","findIndex","w","widgetsWithoutMoved","filter","adjustedInsertIndex","newWidgets","splice","findRowContainingWidget","widgetRows","widgetIndex","undefined","find","row","resizeRowAfterRemoval","removedWidgetId","remainingWidgets","resizeRowAfterAddition","addedWidget","targetRowWidgets","existingIndex","insertPosition","isLastWidgetInRow","i","nextWidgetWidth","canResizeBetweenWidgets","leftWidgetId","rightWidgetId","leftIndex","rightIndex","canLeftShrink","canRightShrink","canLeftGrow","canRightGrow","filterWidgetsByHomepageLayout","homepageLayout","createHomepageWidgetUidsSet","Set","homepageWidgetUids","has","sortWidgetsByHomepageLayout","widgetOrderMap","Map","sort","a","b","aIndex","get","Number","MAX_SAFE_INTEGER","bIndex","applyHomepageLayout","authorizedWidgets","layoutWidgets","sortedWidgets","widths","filteredWidgets","createDefaultWidgetWidths","defaultWidths"],"mappings":";;AAAA;;;;;;;UAYaA,aAAgB,GAAA;IAC3BC,aAAe,EAAA,EAAA;IACfC,gBAAkB,EAAA,CAAA;IAClBC,cAAgB,EAAA;AAAC,QAAA,CAAA;AAAG,QAAA,CAAA;AAAG,QAAA,CAAA;AAAG,QAAA;AAAG;AAC/B;MAEaC,sBAAyB,GAAA;IACpCC,SAAW,EAAA,uBAAA;IACXC,cAAgB,EAAA;AAClB;AAEO,MAAMC,mBAAmB,CAACC,GAAAA,GAAAA;AAC/B,IAAA,OAAOC,QAASC,CAAAA,aAAa,CAAC,CAAC,CAAC,EAAEN,sBAAuBC,CAAAA,SAAS,CAAC,EAAE,EAAEG,GAAAA,CAAI,EAAE,CAAC,CAAA;AAChF;MAEaG,sBAAyB,GAAA,IAAA;IACpC,OAAOF,QAAAA,CAASC,aAAa,CAAC,CAAC,CAAC,EAAEN,sBAAuBE,CAAAA,cAAc,CAAC,CAAC,CAAC,CAAA;AAC5E;AASA;;IAGaM,MAAAA,kBAAAA,GAAqB,CAACC,KAAAA,GAAAA;AACjC,IAAA,OAAOA,SAASb,aAAcE,CAAAA,gBAAgB,IAAIW,KAAAA,IAASb,cAAcC,aAAa;AACxF;AAEA;;AAEC,IACM,MAAMa,sBAAyB,GAAA,CAACC,SAAmBC,EAAAA,UAAAA,GAAAA;;AAExD,IAAA,IAAI,CAACJ,kBAAAA,CAAmBG,SAAc,CAAA,IAAA,CAACH,mBAAmBI,UAAa,CAAA,EAAA;QACrE,OAAO,KAAA;AACT;;AAGA,IAAA,IAAID,SAAYC,GAAAA,UAAAA,GAAahB,aAAcC,CAAAA,aAAa,EAAE;QACxD,OAAO,KAAA;AACT;IAEA,OAAO,IAAA;AACT;AAEA;;AAEC,IACYgB,MAAAA,cAAAA,GAAiB,CAC5BC,YACAC,EAAAA,QAAAA,EACAC,eAAuB,CAAC,GAAA;AAExB,IAAA,OAAOD,QAAWD,GAAAA,YAAY,CAACC,QAAAA,CAAS,IAAIC,YAAeA,GAAAA,YAAAA;AAC7D;AAEA;;AAEC,IACM,MAAMC,mBAAsB,GAAA,CACjCC,OACAJ,EAAAA,YAAAA,GAAAA;AAEA,IAAA,MAAMK,OAAoB,EAAE;AAC5B,IAAA,IAAIC,aAA8B,EAAE;AACpC,IAAA,IAAIC,eAAkB,GAAA,CAAA;AACtB,IAAA,IAAIC,UAAa,GAAA,CAAA;IAEjBJ,OAAQK,CAAAA,OAAO,CAAC,CAACC,MAAQC,EAAAA,KAAAA,GAAAA;AACvB,QAAA,MAAMC,WAAcb,GAAAA,cAAAA,CAAeC,YAAcU,EAAAA,MAAAA,CAAOpB,GAAG,CAAA;;AAG3D,QAAA,IAAIiB,eAAkBK,GAAAA,WAAAA,GAAc9B,aAAcC,CAAAA,aAAa,EAAE;YAC/D,IAAIuB,UAAAA,CAAWO,MAAM,GAAG,CAAG,EAAA;AACzBR,gBAAAA,IAAAA,CAAKS,IAAI,CAAC;oBACRV,OAASE,EAAAA,UAAAA;oBACTS,UAAYR,EAAAA,eAAAA;AACZC,oBAAAA,UAAAA;oBACAQ,QAAUR,EAAAA,UAAAA,GAAaF,UAAWO,CAAAA,MAAM,GAAG;AAC7C,iBAAA,CAAA;AACF;YACAP,UAAa,GAAA;AAACI,gBAAAA;AAAO,aAAA;YACrBH,eAAkBK,GAAAA,WAAAA;YAClBJ,UAAaG,GAAAA,KAAAA;SACR,MAAA;AACLL,YAAAA,UAAAA,CAAWQ,IAAI,CAACJ,MAAAA,CAAAA;YAChBH,eAAmBK,IAAAA,WAAAA;AACrB;AACF,KAAA,CAAA;;IAGA,IAAIN,UAAAA,CAAWO,MAAM,GAAG,CAAG,EAAA;AACzBR,QAAAA,IAAAA,CAAKS,IAAI,CAAC;YACRV,OAASE,EAAAA,UAAAA;YACTS,UAAYR,EAAAA,eAAAA;AACZC,YAAAA,UAAAA;YACAQ,QAAUR,EAAAA,UAAAA,GAAaF,UAAWO,CAAAA,MAAM,GAAG;AAC7C,SAAA,CAAA;AACF;IAEA,OAAOR,IAAAA;AACT;AAEA;;;;;;AAMC,IACM,MAAMY,4BAA+B,GAAA,CAC1CC,YACAC,EAAAA,mBAAAA,GAAAA;AAEA,IAAA,MAAMC,SAAY,GAAA;AAAE,QAAA,GAAGD;AAAoB,KAAA;IAC3C,MAAME,WAAAA,GAAcH,aAAaL,MAAM;AAEvC,IAAA,IAAIQ,gBAAgB,CAAG,EAAA;;AAErBD,QAAAA,SAAS,CAACF,YAAY,CAAC,EAAE,CAAC5B,GAAG,CAAC,GAAG,EAAA;KAC5B,MAAA,IAAI+B,gBAAgB,CAAG,EAAA;;QAE5BH,YAAaT,CAAAA,OAAO,CAAC,CAACC,MAAAA,GAAAA;AACpBU,YAAAA,SAAS,CAACV,MAAAA,CAAOpB,GAAG,CAAC,GAAG,CAAA;AAC1B,SAAA,CAAA;KACK,MAAA,IAAI+B,gBAAgB,CAAG,EAAA;;QAE5B,MAAMC,aAAAA,GAAgBJ,aAAaK,GAAG,CAAC,CAACb,MACtCX,GAAAA,cAAAA,CAAeoB,mBAAqBT,EAAAA,MAAAA,CAAOpB,GAAG,CAAA,CAAA;QAEhD,MAAMyB,UAAAA,GAAaO,cAAcE,MAAM,CAAC,CAACC,GAAK9B,EAAAA,KAAAA,GAAU8B,MAAM9B,KAAO,EAAA,CAAA,CAAA;AAErE,QAAA,IAAIoB,eAAe,EAAI,EAAA;;YAErBG,YAAaT,CAAAA,OAAO,CAAC,CAACC,MAAQC,EAAAA,KAAAA,GAAAA;AAC5BS,gBAAAA,SAAS,CAACV,MAAOpB,CAAAA,GAAG,CAAC,GAAGgC,aAAa,CAACX,KAAM,CAAA;AAC9C,aAAA,CAAA;SACK,MAAA;;YAELO,YAAaT,CAAAA,OAAO,CAAC,CAACC,MAAAA,GAAAA;AACpBU,gBAAAA,SAAS,CAACV,MAAAA,CAAOpB,GAAG,CAAC,GAAG,CAAA;AAC1B,aAAA,CAAA;AACF;AACF;IAEA,OAAO8B,SAAAA;AACT;AAEaM,MAAAA,iBAAAA,GAAoB,CAC/BtB,OAAAA,EACAH,QACA0B,EAAAA,WAAAA,GAAAA;IAEA,MAAMC,YAAAA,GAAexB,QAAQyB,SAAS,CAAC,CAACC,CAAMA,GAAAA,CAAAA,CAAExC,GAAG,KAAKW,QAAAA,CAAAA;IACxD,IAAI2B,YAAAA,KAAiB,CAAC,CAAA,EAAG,OAAOxB,OAAAA;;IAGhC,MAAM2B,mBAAAA,GAAsB3B,QAAQ4B,MAAM,CAAC,CAACF,CAAMA,GAAAA,CAAAA,CAAExC,GAAG,KAAKW,QAAAA,CAAAA;;AAG5D,IAAA,MAAMgC,mBAAsBN,GAAAA,WAAAA,GAAcC,YAAeD,GAAAA,WAAAA,GAAc,CAAIA,GAAAA,WAAAA;AAC3E,IAAA,MAAMO,UAAa,GAAA;AAAIH,QAAAA,GAAAA;AAAoB,KAAA;AAC3CG,IAAAA,UAAAA,CAAWC,MAAM,CAACF,mBAAAA,EAAqB,CAAG7B,EAAAA,OAAO,CAACwB,YAAa,CAAA,CAAA;IAE/D,OAAOM,UAAAA;AACT;AAEaE,MAAAA,uBAAAA,GAA0B,CACrCC,UAAAA,EACApC,QACAG,EAAAA,OAAAA,GAAAA;IAEA,MAAMkC,WAAAA,GAAclC,QAAQyB,SAAS,CAAC,CAACC,CAAMA,GAAAA,CAAAA,CAAExC,GAAG,KAAKW,QAAAA,CAAAA;IACvD,IAAIqC,WAAAA,KAAgB,CAAC,CAAA,EAAG,OAAOC,SAAAA;IAE/B,OAAOF,UAAAA,CAAWG,IAAI,CAAC,CAACC,GAAAA,GAAQH,WAAeG,IAAAA,GAAAA,CAAIjC,UAAU,IAAI8B,WAAeG,IAAAA,GAAAA,CAAIzB,QAAQ,CAAA;AAC9F;AAEa0B,MAAAA,qBAAAA,GAAwB,CACnCD,GAAAA,EACAE,eACArB,EAAAA,aAAAA,GAAAA;IAEA,IAAI,CAACmB,KAAK,OAAOnB,aAAAA;IAEjB,MAAMsB,gBAAAA,GAAmBH,GAAIrC,CAAAA,OAAO,CAAC4B,MAAM,CAAC,CAACF,CAAAA,GAAMA,CAAExC,CAAAA,GAAG,KAAKqD,eAAAA,CAAAA;AAC7D,IAAA,OAAO1B,6BAA6B2B,gBAAkBtB,EAAAA,aAAAA,CAAAA;AACxD;AAEauB,MAAAA,sBAAAA,GAAyB,CACpCJ,GAAAA,EACAK,aACAnB,WACAL,EAAAA,aAAAA,GAAAA;IAEA,IAAI,CAACmB,KAAK,OAAOnB,aAAAA;;AAGjB,IAAA,MAAMyB,gBAAmB,GAAA;AAAIN,QAAAA,GAAAA,GAAAA,CAAIrC;AAAQ,KAAA;IACzC,MAAM4C,aAAAA,GAAgBD,gBAAiBlB,CAAAA,SAAS,CAAC,CAACC,IAAMA,CAAExC,CAAAA,GAAG,KAAKwD,WAAAA,CAAYxD,GAAG,CAAA;IAEjF,IAAI0D,aAAAA,KAAkB,CAAC,CAAG,EAAA;;QAExBD,gBAAiBZ,CAAAA,MAAM,CAACa,aAAe,EAAA,CAAA,CAAA;AACzC;;IAGA,IAAIC,cAAAA,GAAiBtB,WAAcc,GAAAA,GAAAA,CAAIjC,UAAU;;;AAIjD,IAAA,IAAImB,WAAgBc,KAAAA,GAAAA,CAAIzB,QAAQ,GAAG,CAAG,EAAA;QACpCiC,cAAiBR,GAAAA,GAAAA,CAAIrC,OAAO,CAACS,MAAM;AACrC;IAEAkC,gBAAiBZ,CAAAA,MAAM,CAACc,cAAAA,EAAgB,CAAGH,EAAAA,WAAAA,CAAAA;AAE3C,IAAA,OAAO7B,6BAA6B8B,gBAAkBzB,EAAAA,aAAAA,CAAAA;AACxD;AAEa4B,MAAAA,iBAAAA,GAAoB,CAC/BZ,WAAAA,EACAlC,OACAJ,EAAAA,YAAAA,GAAAA;AAEA,IAAA,IAAIsC,WAAelC,IAAAA,OAAAA,CAAQS,MAAM,GAAG,CAAG,EAAA;AACrC,QAAA,OAAO;AACT;AAEA,IAAA,IAAIN,eAAkB,GAAA,CAAA;;AAGtB,IAAA,IAAK,IAAI4C,CAAAA,GAAI,CAAGA,EAAAA,CAAAA,IAAKb,aAAaa,CAAK,EAAA,CAAA;AACrC,QAAA,MAAMvC,cAAcb,cAAeC,CAAAA,YAAAA,EAAcI,OAAO,CAAC+C,EAAE,EAAE7D,GAAAA,CAAAA;AAC7D,QAAA,IAAIiB,eAAkBK,GAAAA,WAAAA,GAAc9B,aAAcC,CAAAA,aAAa,EAAE;;YAE/DwB,eAAkBK,GAAAA,WAAAA;SACb,MAAA;YACLL,eAAmBK,IAAAA,WAAAA;AACrB;AACF;;AAGA,IAAA,MAAMwC,kBAAkBrD,cAAeC,CAAAA,YAAAA,EAAcI,OAAO,CAACkC,WAAAA,GAAc,EAAE,EAAEhD,GAAAA,CAAAA;IAC/E,OAAOiB,eAAAA,GAAkB6C,eAAkBtE,GAAAA,aAAAA,CAAcC,aAAa;AACxE;AAEasE,MAAAA,uBAAAA,GAA0B,CACrCC,YAAAA,EACAC,eACAvD,YACAI,EAAAA,OAAAA,GAAAA;IAEA,MAAMP,SAAAA,GAAYE,eAAeC,YAAcsD,EAAAA,YAAAA,CAAAA;IAC/C,MAAMxD,UAAAA,GAAaC,eAAeC,YAAcuD,EAAAA,aAAAA,CAAAA;;IAGhD,MAAMC,SAAAA,GAAYpD,QAAQyB,SAAS,CAAC,CAACC,CAAMA,GAAAA,CAAAA,CAAExC,GAAG,KAAKgE,YAAAA,CAAAA;IACrD,MAAMG,UAAAA,GAAarD,QAAQyB,SAAS,CAAC,CAACC,CAAMA,GAAAA,CAAAA,CAAExC,GAAG,KAAKiE,aAAAA,CAAAA;;IAGtD,IAAIE,UAAAA,KAAeD,YAAY,CAAG,EAAA;QAChC,OAAO,KAAA;AACT;;IAGA,IAAIN,iBAAAA,CAAkBM,SAAWpD,EAAAA,OAAAA,EAASJ,YAAe,CAAA,EAAA;AACvD,QAAA,OAAO;AACT;;;IAIA,MAAM0D,aAAAA,GAAgB7D,SAAYf,GAAAA,aAAAA,CAAcE,gBAAgB;IAChE,MAAM2E,cAAAA,GAAiB7D,UAAahB,GAAAA,aAAAA,CAAcE,gBAAgB;IAClE,MAAM4E,WAAAA,GAAc/D,SAAYf,GAAAA,aAAAA,CAAcC,aAAa;IAC3D,MAAM8E,YAAAA,GAAe/D,UAAahB,GAAAA,aAAAA,CAAcC,aAAa;;IAG7D,OAAQ2E,aAAiBG,IAAAA,YAAAA,IAAkBF,cAAkBC,IAAAA,WAAAA;AAC/D;AAEA;;AAEC,IACM,MAAME,6BAAgC,GAAA,CAC3C1D,OACA2D,EAAAA,cAAAA,GAAAA;AAEA,IAAA,MAAMC,2BAA8B,GAAA,CAACD,cACnC,GAAA,IAAIE,GAAIF,CAAAA,cAAAA,CAAe3D,OAAO,CAACmB,GAAG,CAAC,CAACO,CAAAA,GAAMA,EAAExC,GAAG,CAAA,CAAA;AACjD,IAAA,MAAM4E,qBAAqBF,2BAA4BD,CAAAA,cAAAA,CAAAA;IACvD,OAAO3D,OAAAA,CAAQ4B,MAAM,CAAC,CAACtB,SAAWwD,kBAAmBC,CAAAA,GAAG,CAACzD,MAAAA,CAAOpB,GAAG,CAAA,CAAA;AACrE;AAEA;;AAEC,IACM,MAAM8E,2BAA8B,GAAA,CACzChE,OACA2D,EAAAA,cAAAA,GAAAA;IAEA,MAAMM,cAAAA,GAAiB,IAAIC,GAAAA,CACzBP,cAAe3D,CAAAA,OAAO,CAACmB,GAAG,CAAC,CAACb,MAAAA,EAAQC,KAAU,GAAA;AAACD,YAAAA,MAAAA,CAAOpB,GAAG;AAAEqB,YAAAA;AAAM,SAAA,CAAA,CAAA;IAGnE,OAAO;AAAIP,QAAAA,GAAAA;KAAQ,CAACmE,IAAI,CAAC,CAACC,CAAGC,EAAAA,CAAAA,GAAAA;QAC3B,MAAMC,MAAAA,GAASL,eAAeM,GAAG,CAACH,EAAElF,GAAG,CAAA,IAAKsF,OAAOC,gBAAgB;QACnE,MAAMC,MAAAA,GAAST,eAAeM,GAAG,CAACF,EAAEnF,GAAG,CAAA,IAAKsF,OAAOC,gBAAgB;AACnE,QAAA,OAAOH,MAASI,GAAAA,MAAAA;AAClB,KAAA,CAAA;AACF;AAEA;;AAEC,IACM,MAAMC,mBAAsB,GAAA,CACjCC,iBACAjB,EAAAA,cAAAA,GAAAA;IAKA,MAAMkB,aAAAA,GAAgBnB,8BAA8BkB,iBAAmBjB,EAAAA,cAAAA,CAAAA;IACvE,MAAMmB,aAAAA,GAAgBd,4BAA4Ba,aAAelB,EAAAA,cAAAA,CAAAA;;AAGjE,IAAA,MAAMoB,SAAiC,EAAC;IACxCpB,cAAe3D,CAAAA,OAAO,CAACK,OAAO,CAAC,CAAC,EAAEnB,GAAG,EAAEK,KAAK,EAAE,GAAA;QAC5CwF,MAAM,CAAC7F,IAAI,GAAGK,KAAAA;AAChB,KAAA,CAAA;IAEA,OAAO;QACLyF,eAAiBF,EAAAA,aAAAA;AACjBC,QAAAA;AACF,KAAA;AACF;AAEA;;;;IAKaE,MAAAA,yBAAAA,GAA4B,CAACjF,OAAAA,GAAAA;AACxC,IAAA,MAAMkF,gBAAwC,EAAC;IAC/C,MAAMjE,WAAAA,GAAcjB,QAAQS,MAAM;AAElC,IAAA,IAAIQ,cAAc,CAAG,EAAA;QACnB,IAAIA,WAAAA,GAAc,MAAM,CAAG,EAAA;YACzBjB,OAAQK,CAAAA,OAAO,CAAC,CAACC,MAAAA,GAAAA;AACf4E,gBAAAA,aAAa,CAAC5E,MAAAA,CAAOpB,GAAG,CAAC,GAAG,CAAA;AAC9B,aAAA,CAAA;SACK,MAAA;YACLc,OAAQK,CAAAA,OAAO,CAAC,CAACC,MAAQC,EAAAA,KAAAA,GAAAA;gBACvB2E,aAAa,CAAC5E,OAAOpB,GAAG,CAAC,GAAGqB,KAAUU,KAAAA,WAAAA,GAAc,IAAI,EAAK,GAAA,CAAA;AAC/D,aAAA,CAAA;AACF;AACF;IAEA,OAAOiE,aAAAA;AACT;;;;;;;;;;;;;;;;;;;;;;"}