{"version":3,"file":"clean-component-join-table.mjs","sources":["../../../../src/services/document-service/utils/clean-component-join-table.ts"],"sourcesContent":["import type { Database } from '@strapi/database';\nimport type { Schema } from '@strapi/types';\nimport { findComponentParent, getParentSchemasForComponent } from '../components';\n\n/**\n * Cleans ghost relations with publication state mismatches from a join table\n * Uses schema-based draft/publish checking like prevention fix\n */\nexport const cleanComponentJoinTable = async (\n  db: Database,\n  joinTableName: string,\n  relation: any,\n  sourceModel: any\n): Promise<number> => {\n  try {\n    // Get the target model metadata\n    const targetModel = db.metadata.get(relation.target);\n    if (!targetModel) {\n      db.logger.debug(`Target model ${relation.target} not found, skipping ${joinTableName}`);\n      return 0;\n    }\n\n    // Check if source supports draft/publish, if it doesnt it should contain duplicate states\n    const sourceContentType = strapi.contentTypes[sourceModel.uid];\n    // It could be a model, which does not have the draftAndPublish option\n    const sourceSupportsDraftPublish = sourceContentType?.options?.draftAndPublish;\n\n    if (sourceContentType && !sourceSupportsDraftPublish) {\n      return 0;\n    }\n\n    // Check if target supports draft/publish using schema-based approach (like prevention fix)\n    const targetContentType =\n      strapi.contentTypes[relation.target as keyof typeof strapi.contentTypes];\n    const targetSupportsDraftPublish = targetContentType?.options?.draftAndPublish || false;\n\n    if (!targetSupportsDraftPublish) {\n      return 0;\n    }\n\n    // Find entries with publication state mismatches\n    const ghostEntries = await findPublicationStateMismatches(\n      db,\n      joinTableName,\n      relation,\n      targetModel,\n      sourceModel\n    );\n\n    if (ghostEntries.length === 0) {\n      return 0;\n    }\n\n    // Remove ghost entries\n    await db.connection(joinTableName).whereIn('id', ghostEntries).del();\n    db.logger.debug(\n      `Removed ${ghostEntries.length} ghost relations with publication state mismatches from ${joinTableName}`\n    );\n\n    return ghostEntries.length;\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    db.logger.error(`Failed to clean join table \"${joinTableName}\": ${errorMessage}`);\n    return 0;\n  }\n};\n\nconst findContentTypeParentForComponentInstance = async (\n  componentSchema: Schema.Component,\n  componentId: number | string\n): Promise<{ uid: string; table: string; parentId: number | string } | null> => {\n  // Get the parent schemas that could contain this component\n  const parentSchemas = getParentSchemasForComponent(componentSchema);\n  if (parentSchemas.length === 0) {\n    // No potential parents\n    return null;\n  }\n\n  // Find the actual parent for THIS specific component instance\n  const parent = await findComponentParent(componentSchema, componentId, parentSchemas);\n  if (!parent) {\n    // No parent found for this component instance\n    return null;\n  }\n\n  if (strapi.components[parent.uid as keyof typeof strapi.components]) {\n    // If the parent is a component, we need to check its parents recursively\n    const parentComponentSchema = strapi.components[parent.uid as keyof typeof strapi.components];\n    return findContentTypeParentForComponentInstance(parentComponentSchema, parent.parentId);\n  }\n\n  if (strapi.contentTypes[parent.uid as keyof typeof strapi.contentTypes]) {\n    // Found a content type parent\n    return parent;\n  }\n\n  return null;\n};\n\n/**\n * Finds join table entries with publication state mismatches\n * Uses existing component parent detection from document service\n */\nconst findPublicationStateMismatches = async (\n  db: Database,\n  joinTableName: string,\n  relation: any,\n  targetModel: any,\n  sourceModel: any\n): Promise<number[]> => {\n  try {\n    // Get join column names using proper functions (addressing PR feedback)\n    const sourceColumn = relation.joinTable.joinColumn.name;\n    const targetColumn = relation.joinTable.inverseJoinColumn.name;\n\n    // Get all join entries with their target entities\n    const query = db\n      .connection(joinTableName)\n      .select(\n        `${joinTableName}.id as join_id`,\n        `${joinTableName}.${sourceColumn} as source_id`,\n        `${joinTableName}.${targetColumn} as target_id`,\n        `${targetModel.tableName}.published_at as target_published_at`\n      )\n      .leftJoin(\n        targetModel.tableName,\n        `${joinTableName}.${targetColumn}`,\n        `${targetModel.tableName}.id`\n      );\n\n    const joinEntries = await query;\n\n    // Group by source_id to find duplicates pointing to draft/published versions of same entity\n    const entriesBySource: { [key: string]: any[] } = {};\n    for (const entry of joinEntries) {\n      const sourceId = entry.source_id;\n      if (!entriesBySource[sourceId]) {\n        entriesBySource[sourceId] = [];\n      }\n      entriesBySource[sourceId].push(entry);\n    }\n\n    const ghostEntries: number[] = [];\n\n    // Check if this is a join table (ends with _lnk)\n    const isRelationJoinTable = joinTableName.endsWith('_lnk');\n    const isComponentModel =\n      !sourceModel.uid?.startsWith('api::') &&\n      !sourceModel.uid?.startsWith('plugin::') &&\n      sourceModel.uid?.includes('.');\n\n    // Check for draft/publish inconsistencies\n    for (const [sourceId, entries] of Object.entries(entriesBySource)) {\n      // Skip entries with single relations\n      if (entries.length <= 1) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      // For component join tables, check if THIS specific component instance's parent supports D&P\n      if (isRelationJoinTable && isComponentModel) {\n        try {\n          const componentSchema = strapi.components[sourceModel.uid] as Schema.Component;\n          if (!componentSchema) {\n            // eslint-disable-next-line no-continue\n            continue;\n          }\n\n          const parent = await findContentTypeParentForComponentInstance(componentSchema, sourceId);\n          if (!parent) {\n            continue;\n          }\n\n          // Check if THIS component instance's parent supports draft/publish\n          const parentContentType =\n            strapi.contentTypes[parent.uid as keyof typeof strapi.contentTypes];\n          if (!parentContentType?.options?.draftAndPublish) {\n            // This component instance's parent does NOT support D&P - skip cleanup\n            // eslint-disable-next-line no-continue\n            continue;\n          }\n\n          // If we reach here, this component instance's parent DOES support D&P\n          // Continue to process this component instance for ghost relations\n        } catch (error) {\n          // Skip this component instance on error\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n      }\n\n      // Find ghost relations (same logic as original but with improved parent checking)\n      for (const entry of entries) {\n        if (entry.target_published_at === null) {\n          // This is a draft target - find its published version\n          const draftTarget = await db\n            .connection(targetModel.tableName)\n            .select('document_id')\n            .where('id', entry.target_id)\n            .first();\n\n          if (draftTarget) {\n            const publishedVersion = await db\n              .connection(targetModel.tableName)\n              .select('id', 'document_id')\n              .where('document_id', draftTarget.document_id)\n              .whereNotNull('published_at')\n              .first();\n\n            if (publishedVersion) {\n              // Check if we also have a relation to the published version\n              const publishedRelation = entries.find((e) => e.target_id === publishedVersion.id);\n              if (publishedRelation) {\n                ghostEntries.push(publishedRelation.join_id);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return ghostEntries;\n  } catch (error) {\n    return [];\n  }\n};\n"],"names":["cleanComponentJoinTable","db","joinTableName","relation","sourceModel","targetModel","metadata","get","target","logger","debug","sourceContentType","strapi","contentTypes","uid","sourceSupportsDraftPublish","options","draftAndPublish","targetContentType","targetSupportsDraftPublish","ghostEntries","findPublicationStateMismatches","length","connection","whereIn","del","error","errorMessage","Error","message","String","findContentTypeParentForComponentInstance","componentSchema","componentId","parentSchemas","getParentSchemasForComponent","parent","findComponentParent","components","parentComponentSchema","parentId","sourceColumn","joinTable","joinColumn","name","targetColumn","inverseJoinColumn","query","select","tableName","leftJoin","joinEntries","entriesBySource","entry","sourceId","source_id","push","isRelationJoinTable","endsWith","isComponentModel","startsWith","includes","entries","Object","parentContentType","target_published_at","draftTarget","where","target_id","first","publishedVersion","document_id","whereNotNull","publishedRelation","find","e","id","join_id"],"mappings":"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"}